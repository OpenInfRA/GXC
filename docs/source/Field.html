<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
This file is part of Ext JS 4.2

Copyright (c) 2011-2013 Sencha Inc

Contact:  http://www.sencha.com/contact

GNU General Public License Usage
This file may be used under the terms of the GNU General Public License version 3.0 as
published by the Free Software Foundation and appearing in the file LICENSE included in the
packaging of this file.

Please review the following information to ensure the GNU General Public License version 3.0
requirements will be met: http://www.gnu.org/copyleft/gpl.html.

If you are unsure which license is appropriate for your use, please contact the sales department
at http://www.sencha.com/contact.

Build date: 2013-05-16 14:36:50 (f9be68accb407158ba2b1be2c226a6ce1f649314)
*/
<span id='Ext-data-Field'>/**
</span> * @author Ed Spencer
 *
 * Fields are used to define what a Model is. They aren&#39;t instantiated directly - instead, when we create a class that
 * extends {@link Ext.data.Model}, it will automatically create a Field instance for each field configured in a {@link
 * Ext.data.Model Model}. For example, we might set up a model like this:
 *
 *     Ext.define(&#39;User&#39;, {
 *         extend: &#39;Ext.data.Model&#39;,
 *         fields: [
 *             &#39;name&#39;, &#39;email&#39;,
 *             {name: &#39;age&#39;, type: &#39;int&#39;},
 *             {name: &#39;gender&#39;, type: &#39;string&#39;, defaultValue: &#39;Unknown&#39;}
 *         ]
 *     });
 *
 * Four fields will have been created for the User Model - name, email, age and gender. Note that we specified a couple
 * of different formats here; if we only pass in the string name of the field (as with name and email), the field is set
 * up with the &#39;auto&#39; type. It&#39;s as if we&#39;d done this instead:
 *
 *     Ext.define(&#39;User&#39;, {
 *         extend: &#39;Ext.data.Model&#39;,
 *         fields: [
 *             {name: &#39;name&#39;, type: &#39;auto&#39;},
 *             {name: &#39;email&#39;, type: &#39;auto&#39;},
 *             {name: &#39;age&#39;, type: &#39;int&#39;},
 *             {name: &#39;gender&#39;, type: &#39;string&#39;, defaultValue: &#39;Unknown&#39;}
 *         ]
 *     });
 *
 * # Types and conversion
 *
 * The {@link #type} is important - it&#39;s used to automatically convert data passed to the field into the correct format.
 * In our example above, the name and email fields used the &#39;auto&#39; type and will just accept anything that is passed
 * into them. The &#39;age&#39; field had an &#39;int&#39; type however, so if we passed 25.4 this would be rounded to 25.
 *
 * Sometimes a simple type isn&#39;t enough, or we want to perform some processing when we load a Field&#39;s data. We can do
 * this using a {@link #convert} function. Here, we&#39;re going to create a new field based on another:
 *
 *     Ext.define(&#39;User&#39;, {
 *         extend: &#39;Ext.data.Model&#39;,
 *         fields: [
 *             {
 *                 name: &#39;firstName&#39;,
 *                 convert: function(value, record) {
 *                     var fullName  = record.get(&#39;name&#39;),
 *                         splits    = fullName.split(&quot; &quot;),
 *                         firstName = splits[0];
 *
 *                     return firstName;
 *                 }
 *             },
 *             &#39;name&#39;, &#39;email&#39;,
 *             {name: &#39;age&#39;, type: &#39;int&#39;},
 *             {name: &#39;gender&#39;, type: &#39;string&#39;, defaultValue: &#39;Unknown&#39;}
 *         ]
 *     });
 *
 * Now when we create a new User, the firstName is populated automatically based on the name:
 *
 *     var ed = Ext.create(&#39;User&#39;, {name: &#39;Ed Spencer&#39;});
 *
 *     console.log(ed.get(&#39;firstName&#39;)); //logs &#39;Ed&#39;, based on our convert function
 *     
 * Fields which are configured with a custom ```convert``` function are read *after* all other fields
 * when constructing and reading records, so that if convert functions rely on other, non-converted fields
 * (as in this example), they can be sure of those fields being present.
 *
 * In fact, if we log out all of the data inside ed, we&#39;ll see this:
 *
 *     console.log(ed.data);
 *
 *     //outputs this:
 *     {
 *         age: 0,
 *         email: &quot;&quot;,
 *         firstName: &quot;Ed&quot;,
 *         gender: &quot;Unknown&quot;,
 *         name: &quot;Ed Spencer&quot;
 *     }
 *
 * The age field has been given a default of zero because we made it an int type. As an auto field, email has defaulted
 * to an empty string. When we registered the User model we set gender&#39;s {@link #defaultValue} to &#39;Unknown&#39; so we see
 * that now. Let&#39;s correct that and satisfy ourselves that the types work as we expect:
 *
 *     ed.set(&#39;gender&#39;, &#39;Male&#39;);
 *     ed.get(&#39;gender&#39;); //returns &#39;Male&#39;
 *
 *     ed.set(&#39;age&#39;, 25.4);
 *     ed.get(&#39;age&#39;); //returns 25 - we wanted an int, not a float, so no decimal places allowed
 */
Ext.define(&#39;Ext.data.Field&#39;, {
    requires: [&#39;Ext.data.Types&#39;, &#39;Ext.data.SortTypes&#39;],
    alias: &#39;data.field&#39;,

<span id='Ext-data-Field-property-isField'>    isField: true,
</span>    
<span id='Ext-data-Field-method-constructor'>    constructor : function(config) {
</span>        var me = this,
            types = Ext.data.Types,
            st;
        
        if (Ext.isString(config)) {
            config = {name: config};
        }
        Ext.apply(me, config);

        st = me.sortType;

        if (me.type) {
            if (Ext.isString(me.type)) {
                me.type = types[me.type.toUpperCase()] || types.AUTO;
            }
        } else {
            me.type = types.AUTO;
        }

        // named sortTypes are supported, here we look them up
        if (Ext.isString(st)) {
            me.sortType = Ext.data.SortTypes[st];
        } else if(Ext.isEmpty(st)) {
            me.sortType = me.type.sortType;
        }

        // Reference this type&#39;s default converter if we did not recieve one in configuration.
        if (!config.hasOwnProperty(&#39;convert&#39;)) {
            me.convert = me.type.convert; // this may be undefined (e.g., AUTO)
        } else if (!me.convert &amp;&amp; me.type.convert &amp;&amp; !config.hasOwnProperty(&#39;defaultValue&#39;)) {
            // If the converter has been nulled out, and we have not been configured
            // with a field-specific defaultValue, then coerce the inherited defaultValue into our data type.
            me.defaultValue = me.type.convert(me.defaultValue);
        }

        if (config.convert) {
            me.hasCustomConvert = true;
        }
    },
    
<span id='Ext-data-Field-cfg-name'>    /**
</span>     * @cfg {String} name
     *
     * The name by which the field is referenced within the Model. This is referenced by, for example, the `dataIndex`
     * property in column definition objects passed to {@link Ext.grid.property.HeaderContainer}.
     *
     * Note: In the simplest case, if no properties other than `name` are required, a field definition may consist of
     * just a String for the field name.
     */
    
<span id='Ext-data-Field-cfg-type'>    /**
</span>     * @cfg {String/Object} type
     *
     * The data type for automatic conversion from received data to the *stored* value if
     * `{@link Ext.data.Field#convert convert}` has not been specified. This may be specified as a string value.
     * Possible values are
     *
     * - auto (Default, implies no conversion)
     * - string
     * - int
     * - float
     * - boolean
     * - date
     *
     * This may also be specified by referencing a member of the {@link Ext.data.Types} class.
     *
     * Developers may create their own application-specific data types by defining new members of the {@link
     * Ext.data.Types} class.
     */

<span id='Ext-data-Field-cfg-convert'>    /**
</span>     * @cfg {Function} [convert]
     *
     * A function which converts the value provided by the Reader into an object that will be stored in the Model.
     * 
     * If configured as `null`, then no conversion will be applied to the raw data property when this Field
     * is read. This will increase performance. but you must ensure that the data is of the correct type and does
     * not *need* converting.
     * 
     * It is passed the following parameters:
     *
     * - **v** : Mixed
     *
     *   The data value as read by the Reader, if undefined will use the configured `{@link Ext.data.Field#defaultValue
     *   defaultValue}`.
     *
     * - **rec** : Ext.data.Model
     *
     *   The data object containing the Model as read so far by the Reader. Note that the Model may not be fully populated
     *   at this point as the fields are read in the order that they are defined in your
     *   {@link Ext.data.Model#cfg-fields fields} array.
     *
     * Example of convert functions:
     *
     *     function fullName(v, record){
     *         return record.data.last + &#39;, &#39; + record.data.first;
     *     }
     *
     *     function location(v, record){
     *         return !record.data.city ? &#39;&#39; : (record.data.city + &#39;, &#39; + record.data.state);
     *     }
     *
     *     Ext.define(&#39;Dude&#39;, {
     *         extend: &#39;Ext.data.Model&#39;,
     *         fields: [
     *             {name: &#39;fullname&#39;,  convert: fullName},
     *             {name: &#39;firstname&#39;, mapping: &#39;name.first&#39;},
     *             {name: &#39;lastname&#39;,  mapping: &#39;name.last&#39;},
     *             {name: &#39;city&#39;, defaultValue: &#39;homeless&#39;},
     *             &#39;state&#39;,
     *             {name: &#39;location&#39;,  convert: location}
     *         ]
     *     });
     *
     *     // create the data store
     *     var store = Ext.create(&#39;Ext.data.Store&#39;, {
     *         reader: {
     *             type: &#39;json&#39;,
     *             model: &#39;Dude&#39;,
     *             idProperty: &#39;key&#39;,
     *             root: &#39;daRoot&#39;,
     *             totalProperty: &#39;total&#39;
     *         }
     *     });
     *
     *     var myData = [
     *         { key: 1,
     *           name: { first: &#39;Fat&#39;,    last:  &#39;Albert&#39; }
     *           // notice no city, state provided in data object
     *         },
     *         { key: 2,
     *           name: { first: &#39;Barney&#39;, last:  &#39;Rubble&#39; },
     *           city: &#39;Bedrock&#39;, state: &#39;Stoneridge&#39;
     *         },
     *         { key: 3,
     *           name: { first: &#39;Cliff&#39;,  last:  &#39;Claven&#39; },
     *           city: &#39;Boston&#39;,  state: &#39;MA&#39;
     *         }
     *     ];
     */

<span id='Ext-data-Field-cfg-serialize'>    /**
</span>     * @cfg {Function} [serialize]
     * A function which converts the Model&#39;s value for this Field into a form which can be used by whatever {@link Ext.data.writer.Writer Writer}
     * is being used to sync data with the server.
     * 
     * The function should return a string which represents the Field&#39;s value.
     *
     * It is passed the following parameters:
     *
     * - **v** : Mixed
     *
     *   The Field&#39;s value - the value to be serialized.
     *
     * - **rec** : Ext.data.Model
     *
     *   The record being serialized.
     *
     */

<span id='Ext-data-Field-cfg-dateFormat'>    /**
</span>     * @cfg {String} dateFormat
     *
     * Serves as a default for the {@link #dateReadFormat} and {@link #dateWriteFormat} config options. This
     * will be used in place of those other configurations if not specified.
     * 
     * A format string for the {@link Ext.Date#parse Ext.Date.parse} function, or &quot;timestamp&quot; if the value provided by
     * the Reader is a UNIX timestamp, or &quot;time&quot; if the value provided by the Reader is a javascript millisecond
     * timestamp. See {@link Ext.Date}.
     * 
     * It is quite important to note that while this config is optional, it will default to using the base
     * JavaScript Date object&#39;s `parse` function if not specified, rather than {@link Ext.Date#parse Ext.Date.parse}.
     * This can cause unexpected issues, especially when converting between timezones, or when converting dates that
     * do not have a timezone specified. The behavior of the native `Date.parse` is implementation-specific, and
     * depending on the value of the date string, it might return the UTC date or the local date. __For this reason
     * it is strongly recommended that you always specify an explicit date format when parsing dates.__
     */
    dateFormat: null,
    
<span id='Ext-data-Field-cfg-dateReadFormat'>    /**
</span>     * @cfg {String} dateReadFormat
     * Used when converting received data into a Date when the {@link #type} is specified as `&quot;date&quot;`.
     * This configuration takes precedence over {@link #dateFormat}.
     * See {@link #dateFormat} for more information.
     */
    dateReadFormat: null,
    
<span id='Ext-data-Field-cfg-dateWriteFormat'>    /** 
</span>     * @cfg {String} dateWriteFormat
     * Used to provide a custom format when serializing dates with a {@link Ext.data.writer.Writer}.
     * If this is not specified, the {@link #dateFormat} will be used. See the {@link Ext.data.writer.Writer} 
     * docs for more information on writing dates. 
     *
     * **Note that to use a {@link Ext.data.JsonWriter JsonWriter} to send Microsoft format &quot;JSON&quot; dates, which are in fact
     * invalid JSON, it is not possible to use the standard date serialization pathway or
     * {@link Ext#USE_NATIVE_JSON native browser JSON production}.**
     *
     * To use a {@link Ext.data.JsonWriter JsonWriter} to write dates in a JSON packet in the form `&quot;\/Date(1357372800000)\/&quot;`
     * configure the field like this:
     *
     *    {
     *        type: &#39;date&#39;,
     *        dateFormat: &#39;MS&#39;,             // To parse incoming dates from server correctly
     *        serialize: Ext.identityFn     // An ExtJS-supplied function which returns the arg unchanged
     *    }
     *
     * Then override ExtJS&#39;s JSON date serialize function:
     *
     *    Ext.JSON.encodeDate = function (d) {
     *        return &#39;&quot;&#39; + Ext.Date.format(d, &#39;MS&#39;) + &#39;&quot;&#39;;
     *    };
     */
    dateWriteFormat: null,
    
<span id='Ext-data-Field-cfg-useNull'>    /**
</span>     * @cfg {Boolean} useNull
     *
     * Use when converting received data into a INT, FLOAT, BOOL or STRING type. If the value cannot be
     * parsed, `null` will be used if useNull is true, otherwise a default value for that type will be used:
     *
     * - for INT and FLOAT - `0`.
     * - for STRING - `&quot;&quot;`.
     * - for BOOL - `false`.
     *
     * Note that when parsing of DATE type fails, the value will be `null` regardless of this setting.
     */
    useNull: false,
    
<span id='Ext-data-Field-cfg-defaultValue'>    /**
</span>     * @cfg {Object} [defaultValue=&quot;&quot;]
     *
     * The default value used when the creating an instance from a raw data object, and the property referenced by the
     * `{@link Ext.data.Field#mapping mapping}` does not exist in that data object.
     * 
     * May be specified as `undefined` to prevent defaulting in a value.
     */
    defaultValue: &quot;&quot;,

<span id='Ext-data-Field-cfg-mapping'>    /**
</span>     * @cfg {String/Number} mapping
     *
     * (Optional) A path expression for use by the {@link Ext.data.reader.Reader} implementation that is creating the
     * {@link Ext.data.Model Model} to extract the Field value from the data object. If the path expression is the same
     * as the field name, the mapping may be omitted.
     *
     * The form of the mapping expression depends on the Reader being used.
     *
     * - {@link Ext.data.reader.Json}
     *
     *   The mapping is a string containing the javascript expression to reference the data from an element of the data
     *   item&#39;s {@link Ext.data.reader.Json#cfg-root root} Array. Defaults to the field name.
     *
     * - {@link Ext.data.reader.Xml}
     *
     *   The mapping is an {@link Ext.DomQuery} path to the data item relative to the DOM element that represents the
     *   {@link Ext.data.reader.Xml#record record}. Defaults to the field name.
     *
     * - {@link Ext.data.reader.Array}
     *
     *   The mapping is a number indicating the Array index of the field&#39;s value. Defaults to the field specification&#39;s
     *   Array position.
     *
     * If a more complex value extraction strategy is required, then configure the Field with a {@link #convert}
     * function. This is passed the whole row object, and may interrogate it in whatever way is necessary in order to
     * return the desired data.
     */
    mapping: null,

<span id='Ext-data-Field-cfg-sortType'>    /**
</span>     * @cfg {Function/String} sortType
     *
     * A function which converts a Field&#39;s value to a comparable value in order to ensure correct sort ordering.
     * Predefined functions are provided in {@link Ext.data.SortTypes}. A custom sort example:
     *
     *     // current sort     after sort we want
     *     // +-+------+          +-+------+
     *     // |1|First |          |1|First |
     *     // |2|Last  |          |3|Second|
     *     // |3|Second|          |2|Last  |
     *     // +-+------+          +-+------+
     *
     *     sortType: function(value) {
     *        switch (value.toLowerCase()) // native toLowerCase():
     *        {
     *           case &#39;first&#39;: return 1;
     *           case &#39;second&#39;: return 2;
     *           default: return 3;
     *        }
     *     }
     *
     * May also be set to a String value, corresponding to one of the named sort types in {@link Ext.data.SortTypes}.
     */
    sortType : null,

<span id='Ext-data-Field-cfg-sortDir'>    /**
</span>     * @cfg {String} sortDir
     *
     * Initial direction to sort (`&quot;ASC&quot;` or `&quot;DESC&quot;`). Defaults to `&quot;ASC&quot;`.
     */
    sortDir : &quot;ASC&quot;,

<span id='Ext-data-Field-cfg-allowBlank'>    /**
</span>     * @cfg {Boolean} allowBlank
     * @private
     *
     * Used for validating a {@link Ext.data.Model model}. Defaults to true. An empty value here will cause
     * {@link Ext.data.Model}.{@link Ext.data.Model#isValid isValid} to evaluate to false.
     */
    allowBlank : true,

<span id='Ext-data-Field-cfg-persist'>    /**
</span>     * @cfg {Boolean} persist
     *
     * False to exclude this field from the {@link Ext.data.Model#modified} fields in a model. This will also exclude
     * the field from being written using a {@link Ext.data.writer.Writer}. This option is useful when model fields are
     * used to keep state on the client but do not need to be persisted to the server. Defaults to true.
     */
    persist: true
});
</pre>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
This file is part of Ext JS 4.2

Copyright (c) 2011-2013 Sencha Inc

Contact:  http://www.sencha.com/contact

GNU General Public License Usage
This file may be used under the terms of the GNU General Public License version 3.0 as
published by the Free Software Foundation and appearing in the file LICENSE included in the
packaging of this file.

Please review the following information to ensure the GNU General Public License version 3.0
requirements will be met: http://www.gnu.org/copyleft/gpl.html.

If you are unsure which license is appropriate for your use, please contact the sales department
at http://www.sencha.com/contact.

Build date: 2013-05-16 14:36:50 (f9be68accb407158ba2b1be2c226a6ce1f649314)
*/
<span id='Ext-layout-container-boxOverflow-Menu'>/**
</span> * @private
 */
Ext.define(&#39;Ext.layout.container.boxOverflow.Menu&#39;, {

    /* Begin Definitions */

    extend: &#39;Ext.layout.container.boxOverflow.None&#39;,
    requires: [&#39;Ext.toolbar.Separator&#39;, &#39;Ext.button.Button&#39;],
    alternateClassName: &#39;Ext.layout.boxOverflow.Menu&#39;,
    
    /* End Definitions */

<span id='Ext-layout-container-boxOverflow-Menu-cfg-triggerButtonCls'>    /**
</span>     * @cfg {String} triggerButtonCls
     * CSS class added to the Button which shows the overflow menu.
     */

<span id='Ext-layout-container-boxOverflow-Menu-property-noItemsMenuText'>    /**
</span>     * @property {String} noItemsMenuText
     * HTML fragment to render into the toolbar overflow menu if there are no items to display
     */
    noItemsMenuText : &#39;&lt;div class=&quot;&#39; + Ext.baseCSSPrefix + &#39;toolbar-no-items&quot;&gt;(None)&lt;/div&gt;&#39;,

<span id='Ext-layout-container-boxOverflow-Menu-method-constructor'>    constructor: function(layout) {
</span>        var me = this;

        me.callParent(arguments);

        me.triggerButtonCls = me.triggerButtonCls || Ext.baseCSSPrefix + &#39;box-menu-after&#39;;
<span id='Ext-layout-container-boxOverflow-Menu-property-menuItems'>        /**
</span>         * @property {Array} menuItems
         * Array of all items that are currently hidden and should go into the dropdown menu
         */
        me.menuItems = [];
    },

<span id='Ext-layout-container-boxOverflow-Menu-method-beginLayout'>    beginLayout: function (ownerContext) {
</span>        this.callParent(arguments);

        // Before layout, we need to re-show all items which we may have hidden due to a
        // previous overflow...
        this.clearOverflow(ownerContext);
    },

<span id='Ext-layout-container-boxOverflow-Menu-method-beginLayoutCycle'>    beginLayoutCycle: function (ownerContext, firstCycle) {
</span>        this.callParent(arguments);

        if (!firstCycle) {
            // if we are being re-run, we need to clear any overflow from the last run and
            // recache the childItems collection
            this.clearOverflow(ownerContext);

            this.layout.cacheChildItems(ownerContext);
        }
    },

<span id='Ext-layout-container-boxOverflow-Menu-method-onRemove'>    onRemove: function(comp){
</span>        Ext.Array.remove(this.menuItems, comp);
    },

<span id='Ext-layout-container-boxOverflow-Menu-method-getSuffixConfig'>    // We don&#39;t define a prefix in menu overflow.
</span>    getSuffixConfig: function() {
        var me = this,
            layout = me.layout,
            owner = layout.owner,
            oid = owner.id;

<span id='Ext-layout-container-boxOverflow-Menu-property-menu'>        /**
</span>         * @private
         * @property {Ext.menu.Menu} menu
         * The expand menu - holds items for every item that cannot be shown
         * because the container is currently not large enough.
         */
        me.menu = new Ext.menu.Menu({
            listeners: {
                scope: me,
                beforeshow: me.beforeMenuShow
            }
        });

<span id='Ext-layout-container-boxOverflow-Menu-property-menuTrigger'>        /**
</span>         * @private
         * @property {Ext.button.Button} menuTrigger
         * The expand button which triggers the overflow menu to be shown
         */
        me.menuTrigger = new Ext.button.Button({
            id: oid + &#39;-menu-trigger&#39;,
            cls: Ext.layout.container.Box.prototype.innerCls + &#39; &#39; + me.triggerButtonCls + &#39; &#39; + Ext.baseCSSPrefix + &#39;toolbar-item&#39;,
            plain: owner.usePlainButtons,
            ownerCt: owner, // To enable the Menu to ascertain a valid zIndexManager owner in the same tree
            ownerLayout: layout,
            iconCls: Ext.baseCSSPrefix + me.getOwnerType(owner) + &#39;-more-icon&#39;,
            ui: owner instanceof Ext.toolbar.Toolbar ? &#39;default-toolbar&#39; : &#39;default&#39;,
            menu: me.menu,
            // Menu will be empty when we&#39;re showing it because we populate items after
            showEmptyMenu: true,
            getSplitCls: function() { return &#39;&#39;;}
        });

        return me.menuTrigger.getRenderTree();
    },
    
<span id='Ext-layout-container-boxOverflow-Menu-method-getOverflowCls'>    getOverflowCls: function() {
</span>        return Ext.baseCSSPrefix + this.layout.direction + &#39;-box-overflow-body&#39;;
    },

<span id='Ext-layout-container-boxOverflow-Menu-method-handleOverflow'>    handleOverflow: function(ownerContext) {
</span>        var me = this,
            layout = me.layout,
            names = layout.names,
            plan = ownerContext.state.boxPlan,
            posArgs = [null, null];

        me.showTrigger(ownerContext);

        // Center the menuTrigger button only if we are not vertical.
        // TODO: Should we emulate align: &#39;middle&#39; like this, or should we &#39;stretchmax&#39; the menuTrigger?
        if (me.layout.direction !== &#39;vertical&#39;) {
            posArgs[names.heightIndex] = (plan.maxSize - me.menuTrigger[names.getHeight]()) / 2;
            me.menuTrigger.setPosition.apply(me.menuTrigger, posArgs);
        }

        return {
            reservedSpace: me.triggerTotalWidth
        };
    },

<span id='Ext-layout-container-boxOverflow-Menu-method-captureChildElements'>    /**
</span>     * Finishes the render operation of the trigger Button.
     * @private
     */
    captureChildElements: function() {
        var me = this,
            menuTrigger = me.menuTrigger,
            names = me.layout.names;

        // The rendering flag is set when getRenderTree is called which we do when returning markup string for the owning layout&#39;s &quot;suffix&quot;
        if (menuTrigger.rendering) {
            menuTrigger.finishRender();
            me.triggerTotalWidth = menuTrigger[names.getWidth]() + menuTrigger.el.getMargin(names.parallelMargins);
        }
    },

<span id='Ext-layout-container-boxOverflow-Menu-property-_asLayoutRoot'>    _asLayoutRoot: { isRoot: true },
</span>
<span id='Ext-layout-container-boxOverflow-Menu-method-clearOverflow'>    /**
</span>     * @private
     * Called by the layout, when it determines that there is no overflow.
     * Also called as an interceptor to the layout&#39;s onLayout method to reshow
     * previously hidden overflowing items.
     */
    clearOverflow: function(ownerContext) {
        var me = this,
            items = me.menuItems,
            item,
            i = 0,
            length = items.length,
            owner = me.layout.owner,
            asLayoutRoot = me._asLayoutRoot;

        owner.suspendLayouts();
        me.captureChildElements();
        me.hideTrigger();
        owner.resumeLayouts();

        for (; i &lt; length; i++) {
            item = items[i];

            // What we are doing here is preventing the layout bubble from invalidating our
            // owner component. We need just the button to be added to the layout run.
            item.suspendLayouts();
            item.show();
            item.resumeLayouts(asLayoutRoot);
        }

        items.length = 0;
    },

<span id='Ext-layout-container-boxOverflow-Menu-method-showTrigger'>    /**
</span>     * @private
     * Shows the overflow trigger when enableOverflow is set to true and the items
     * in the layout are too wide to fit in the space available
     */
    showTrigger: function(ownerContext) {
        var me = this,
            layout = me.layout,
            owner = layout.owner,
            names = layout.names,
            startProp = names.x,
            sizeProp = names.width,
            plan = ownerContext.state.boxPlan,
            available = plan.targetSize[sizeProp],
            childItems = ownerContext.childItems,
            len = childItems.length,
            menuTrigger = me.menuTrigger,
            childContext,
            comp, i, props;

        // We don&#39;t want the menuTrigger.show to cause owner&#39;s layout to be invalidated, so
        // we force just the button to be invalidated and added to the current run.
        menuTrigger.suspendLayouts();
        menuTrigger.show();
        menuTrigger.resumeLayouts(me._asLayoutRoot);

        available -= me.triggerTotalWidth;

        owner.suspendLayouts();

        // Hide all items which are off the end, and store them to allow them to be restored
        // before each layout operation.
        me.menuItems.length = 0;
        for (i = 0; i &lt; len; i++) {
            childContext = childItems[i];
            props = childContext.props;
            if (props[startProp] + props[sizeProp] &gt; available) {
                comp = childContext.target;
                me.menuItems.push(comp);
                comp.hide();
            }
        }

        owner.resumeLayouts();
    },

<span id='Ext-layout-container-boxOverflow-Menu-method-hideTrigger'>    /**
</span>     * @private
     */
    hideTrigger: function() {
        var menuTrigger = this.menuTrigger;
        if (menuTrigger) {
            menuTrigger.hide();
        }
    },

<span id='Ext-layout-container-boxOverflow-Menu-method-beforeMenuShow'>    /**
</span>     * @private
     * Called before the overflow menu is shown. This constructs the menu&#39;s items, caching them for as long as it can.
     */
    beforeMenuShow: function(menu) {
        var me = this,
            items = me.menuItems,
            i = 0,
            len   = items.length,
            item,
            prev,
            needsSep = function(group, prev){
                return group.isXType(&#39;buttongroup&#39;) &amp;&amp; !(prev instanceof Ext.toolbar.Separator);
            };

        menu.suspendLayouts();
        me.clearMenu();
        menu.removeAll();

        for (; i &lt; len; i++) {
            item = items[i];

            // Do not show a separator as a first item
            if (!i &amp;&amp; (item instanceof Ext.toolbar.Separator)) {
                continue;
            }
            if (prev &amp;&amp; (needsSep(item, prev) || needsSep(prev, item))) {
                menu.add(&#39;-&#39;);
            }

            me.addComponentToMenu(menu, item);
            prev = item;
        }

        // put something so the menu isn&#39;t empty if no compatible items found
        if (menu.items.length &lt; 1) {
            menu.add(me.noItemsMenuText);
        }
        menu.resumeLayouts();
    },
    
<span id='Ext-layout-container-boxOverflow-Menu-method-createMenuConfig'>    /**
</span>     * @private
     * Returns a menu config for a given component. This config is used to create a menu item
     * to be added to the expander menu
     * @param {Ext.Component} component The component to create the config for
     * @param {Boolean} hideOnClick Passed through to the menu item
     */
    createMenuConfig : function(component, hideOnClick) {
        var me = this,
            config = Ext.apply({}, component.initialConfig),
            group  = component.toggleGroup;

        Ext.copyTo(config, component, [
            &#39;iconCls&#39;, &#39;icon&#39;, &#39;itemId&#39;, &#39;disabled&#39;, &#39;handler&#39;, &#39;scope&#39;, &#39;menu&#39;, &#39;tabIndex&#39;
        ]);

        Ext.apply(config, {
            text       : component.overflowText || component.text,
            hideOnClick: hideOnClick,
            destroyMenu: false,
            listeners  : {}
        });

        // Clone must have same value, and must sync original&#39;s value on change
        if (component.isFormField) {
            config.value = component.getValue();

            // Sync the original component&#39;s value when the clone changes value.
            // This intentionally overwrites any developer-configured change listener on the clone.
            // That&#39;s because we monitor the clone&#39;s change event, and sync the
            // original field by calling setValue, so the original field&#39;s change
            // event will still fire.
            config.listeners.change = function(c, newVal, oldVal) {                            
                component.setValue(newVal);
            }
        }

        // ToggleButtons become CheckItems
        else if (group || component.enableToggle) {
            Ext.apply(config, {
                hideOnClick: false,
                group  : group,
                checked: component.pressed,
                handler: function(item, e) {
                    component.onClick(e);
                }
            });
        }

        // Buttons may have their text or icon changed - this must be propagated to the clone in the overflow menu
        if (component.isButton &amp;&amp; !component.changeListenersAdded) {
            component.on({
                textchange: me.onButtonAttrChange,
                iconchange: me.onButtonAttrChange,
                toggle:     me.onButtonToggle
            });
            component.changeListenersAdded = true;
        }

        // Typically margins are used to separate items in a toolbar
        // but don&#39;t really make a lot of sense in a menu, so we strip
        // them out here.
        delete config.margin;
        delete config.ownerCt;
        delete config.xtype;
        delete config.id;
        delete config.itemId;
        return config;
    },

<span id='Ext-layout-container-boxOverflow-Menu-method-onButtonAttrChange'>    onButtonAttrChange: function(btn) {
</span>        var clone = btn.overflowClone;
        clone.suspendLayouts();
        clone.setText(btn.text);
        clone.setIcon(btn.icon);
        clone.setIconCls(btn.iconCls);
        clone.resumeLayouts(true);
    },

<span id='Ext-layout-container-boxOverflow-Menu-method-onButtonToggle'>    onButtonToggle: function(btn, state) {
</span>        // Keep the clone in sync with the original if necessary
        if (btn.overflowClone.checked !== state) {
            btn.overflowClone.setChecked(state);
        }
    },

<span id='Ext-layout-container-boxOverflow-Menu-method-addComponentToMenu'>    /**
</span>     * @private
     * Adds the given Toolbar item to the given menu. Buttons inside a buttongroup are added individually.
     * @param {Ext.menu.Menu} menu The menu to add to
     * @param {Ext.Component} component The component to add
     * TODO: Implement overrides in Ext.layout.container.boxOverflow which create overrides
     * for SplitButton, Button, ButtonGroup, and TextField. And a generic one for Component
     * which create clones suitable for use in an overflow menu.
     */
    addComponentToMenu : function(menu, component) {
        var me = this,
        i, items, iLen;

        if (component instanceof Ext.toolbar.Separator) {
            menu.add(&#39;-&#39;);
        } else if (component.isComponent) {
            if (component.isXType(&#39;splitbutton&#39;)) {
                component.overflowClone = menu.add(me.createMenuConfig(component, true));

            } else if (component.isXType(&#39;button&#39;)) {
                component.overflowClone = menu.add(me.createMenuConfig(component, !component.menu));

            } else if (component.isXType(&#39;buttongroup&#39;)) {
                items = component.items.items;
                iLen  = items.length;

                for (i = 0; i &lt; iLen; i++) {
                    me.addComponentToMenu(menu, items[i]);
                }
            } else {
                component.overflowClone = menu.add(Ext.create(Ext.getClassName(component), me.createMenuConfig(component)));
            }
        }
    },

<span id='Ext-layout-container-boxOverflow-Menu-method-clearMenu'>    /**
</span>     * @private
     * Deletes the sub-menu of each item in the expander menu. Submenus are created for items such as
     * splitbuttons and buttongroups, where the Toolbar item cannot be represented by a single menu item
     */
    clearMenu : function() {
        var menu = this.menu,
            items, i, iLen, item;
        
        if (menu &amp;&amp; menu.items) {
            items = menu.items.items;
            iLen  = items.length;
            
            for (i = 0; i &lt; iLen; i++) {
                item = items[i];
                if (item.setMenu) {
                    item.setMenu(null);
                }
            }
        }
    },

<span id='Ext-layout-container-boxOverflow-Menu-method-destroy'>    /**
</span>     * @private
     */
    destroy: function() {
        var trigger = this.menuTrigger;
            
        if (trigger &amp;&amp; !this.layout.owner.items.contains(trigger)) {
            // Ensure we delete the ownerCt if it&#39;s not in the items
            // so we don&#39;t get spurious container remove warnings.
            delete trigger.ownerCt;
        }
        Ext.destroy(this.menu, trigger);
    }
});
</pre>
</body>
</html>

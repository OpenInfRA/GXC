<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
This file is part of Ext JS 4.2

Copyright (c) 2011-2013 Sencha Inc

Contact:  http://www.sencha.com/contact

GNU General Public License Usage
This file may be used under the terms of the GNU General Public License version 3.0 as
published by the Free Software Foundation and appearing in the file LICENSE included in the
packaging of this file.

Please review the following information to ensure the GNU General Public License version 3.0
requirements will be met: http://www.gnu.org/copyleft/gpl.html.

If you are unsure which license is appropriate for your use, please contact the sales department
at http://www.sencha.com/contact.

Build date: 2013-05-16 14:36:50 (f9be68accb407158ba2b1be2c226a6ce1f649314)
*/
<span id='Ext-form-field-HtmlEditor'>/**
</span> * Provides a lightweight HTML Editor component. Some toolbar features are not supported by Safari and will be
 * automatically hidden when needed. These are noted in the config options where appropriate.
 *
 * The editor&#39;s toolbar buttons have tooltips defined in the {@link #buttonTips} property, but they are not
 * enabled by default unless the global {@link Ext.tip.QuickTipManager} singleton is
 * {@link Ext.tip.QuickTipManager#init initialized}.
 *
 * An Editor is a sensitive component that can&#39;t be used in all spots standard fields can be used. Putting an
 * Editor within any element that has display set to &#39;none&#39; can cause problems in Safari and Firefox due to their
 * default iframe reloading bugs.
 *
 * # Example usage
 *
 * Simple example rendered with default options:
 *
 *     @example
 *     Ext.tip.QuickTipManager.init();  // enable tooltips
 *     Ext.create(&#39;Ext.form.HtmlEditor&#39;, {
 *         width: 580,
 *         height: 250,
 *         renderTo: Ext.getBody()
 *     });
 *
 * Passed via xtype into a container and with custom options:
 *
 *     @example
 *     Ext.tip.QuickTipManager.init();  // enable tooltips
 *     new Ext.panel.Panel({
 *         title: &#39;HTML Editor&#39;,
 *         renderTo: Ext.getBody(),
 *         width: 550,
 *         height: 250,
 *         frame: true,
 *         layout: &#39;fit&#39;,
 *         items: {
 *             xtype: &#39;htmleditor&#39;,
 *             enableColors: false,
 *             enableAlignments: false
 *         }
 *     });
 *     
 * # Reflow issues
 * 
 * In some browsers, a layout reflow will cause the underlying editor iframe to be reset. This
 * is most commonly seen when using the editor in collapsed panels with animation. In these cases
 * it is best to avoid animation. More information can be found here: https://bugzilla.mozilla.org/show_bug.cgi?id=90268 
 */
Ext.define(&#39;Ext.form.field.HtmlEditor&#39;, {
    extend: &#39;Ext.form.FieldContainer&#39;,
    mixins: {
        field: &#39;Ext.form.field.Field&#39;
    },
    alias: &#39;widget.htmleditor&#39;,
    alternateClassName: &#39;Ext.form.HtmlEditor&#39;,
    requires: [
        &#39;Ext.tip.QuickTipManager&#39;,
        &#39;Ext.picker.Color&#39;,
        &#39;Ext.layout.container.VBox&#39;,
        &#39;Ext.toolbar.Item&#39;,
        &#39;Ext.toolbar.Toolbar&#39;,
        &#39;Ext.util.Format&#39;,
        &#39;Ext.layout.component.field.HtmlEditor&#39;
    ],
    
<span id='Ext-form-field-HtmlEditor-cfg-componentLayout'>    componentLayout: &#39;htmleditor&#39;,
</span>
<span id='Ext-form-field-HtmlEditor-property-componentTpl'>    componentTpl: [
</span>        &#39;{beforeTextAreaTpl}&#39;,
        &#39;&lt;textarea id=&quot;{id}-textareaEl&quot; name=&quot;{name}&quot; tabIndex=&quot;-1&quot; {inputAttrTpl}&#39;,
                 &#39; class=&quot;{textareaCls}&quot; autocomplete=&quot;off&quot;&gt;&#39;,
            &#39;{[Ext.util.Format.htmlEncode(values.value)]}&#39;,
        &#39;&lt;/textarea&gt;&#39;,
        &#39;{afterTextAreaTpl}&#39;,
        &#39;{beforeIFrameTpl}&#39;,
        &#39;&lt;iframe id=&quot;{id}-iframeEl&quot; name=&quot;{iframeName}&quot; frameBorder=&quot;0&quot; {iframeAttrTpl}&#39;,
               &#39; src=&quot;{iframeSrc}&quot; class=&quot;{iframeCls}&quot;&gt;&lt;/iframe&gt;&#39;,
        &#39;{afterIFrameTpl}&#39;,
        {
            disableFormats: true
        }
    ],
    
<span id='Ext-form-field-HtmlEditor-property-stretchInputElFixed'>    stretchInputElFixed: true,
</span>
<span id='Ext-form-field-HtmlEditor-property-subTplInsertions'>    subTplInsertions: [
</span><span id='Ext-form-field-HtmlEditor-cfg-beforeTextAreaTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} beforeTextAreaTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * before the textarea element. If an `XTemplate` is used, the component&#39;s
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        &#39;beforeTextAreaTpl&#39;,

<span id='Ext-form-field-HtmlEditor-cfg-afterTextAreaTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} afterTextAreaTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * after the textarea element. If an `XTemplate` is used, the component&#39;s
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        &#39;afterTextAreaTpl&#39;,

<span id='Ext-form-field-HtmlEditor-cfg-beforeIFrameTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} beforeIFrameTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * before the iframe element. If an `XTemplate` is used, the component&#39;s
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        &#39;beforeIFrameTpl&#39;,

<span id='Ext-form-field-HtmlEditor-cfg-afterIFrameTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} afterIFrameTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * after the iframe element. If an `XTemplate` is used, the component&#39;s
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        &#39;afterIFrameTpl&#39;,

<span id='Ext-form-field-HtmlEditor-cfg-iframeAttrTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} iframeAttrTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * inside the iframe element (as attributes). If an `XTemplate` is used, the component&#39;s
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        &#39;iframeAttrTpl&#39;,

        // inherited
        &#39;inputAttrTpl&#39;
    ],

<span id='Ext-form-field-HtmlEditor-cfg-enableFormat'>    /**
</span>     * @cfg {Boolean} enableFormat
     * Enable the bold, italic and underline buttons
     */
    enableFormat: true,
<span id='Ext-form-field-HtmlEditor-cfg-enableFontSize'>    /**
</span>     * @cfg {Boolean} enableFontSize
     * Enable the increase/decrease font size buttons
     */
    enableFontSize: true,
<span id='Ext-form-field-HtmlEditor-cfg-enableColors'>    /**
</span>     * @cfg {Boolean} enableColors
     * Enable the fore/highlight color buttons
     */
    enableColors: true,
<span id='Ext-form-field-HtmlEditor-cfg-enableAlignments'>    /**
</span>     * @cfg {Boolean} enableAlignments
     * Enable the left, center, right alignment buttons
     */
    enableAlignments: true,
<span id='Ext-form-field-HtmlEditor-cfg-enableLists'>    /**
</span>     * @cfg {Boolean} enableLists
     * Enable the bullet and numbered list buttons. Not available in Safari 2.
     */
    enableLists: true,
<span id='Ext-form-field-HtmlEditor-cfg-enableSourceEdit'>    /**
</span>     * @cfg {Boolean} enableSourceEdit
     * Enable the switch to source edit button. Not available in Safari 2.
     */
    enableSourceEdit: true,
<span id='Ext-form-field-HtmlEditor-cfg-enableLinks'>    /**
</span>     * @cfg {Boolean} enableLinks
     * Enable the create link button. Not available in Safari 2.
     */
    enableLinks: true,
<span id='Ext-form-field-HtmlEditor-cfg-enableFont'>    /**
</span>     * @cfg {Boolean} enableFont
     * Enable font selection. Not available in Safari 2.
     */
    enableFont: true,
    //&lt;locale&gt;
<span id='Ext-form-field-HtmlEditor-cfg-createLinkText'>    /**
</span>     * @cfg {String} createLinkText
     * The default text for the create link prompt
     */
    createLinkText: &#39;Please enter the URL for the link:&#39;,
    //&lt;/locale&gt;
<span id='Ext-form-field-HtmlEditor-cfg-defaultLinkValue'>    /**
</span>     * @cfg {String} [defaultLinkValue=&#39;http://&#39;]
     * The default value for the create link prompt
     */
    defaultLinkValue: &#39;http:/&#39;+&#39;/&#39;,
<span id='Ext-form-field-HtmlEditor-cfg-fontFamilies'>    /**
</span>     * @cfg {String[]} fontFamilies
     * An array of available font families
     */
    fontFamilies: [
        &#39;Arial&#39;,
        &#39;Courier New&#39;,
        &#39;Tahoma&#39;,
        &#39;Times New Roman&#39;,
        &#39;Verdana&#39;
    ],
<span id='Ext-form-field-HtmlEditor-cfg-defaultValue'>    /**
</span>     * @cfg {String} defaultValue
     * A default value to be put into the editor to resolve focus issues.
     *
     * Defaults to (Non-breaking space) in Opera and IE6,
     * (Zero-width space) in all other browsers.
     */
    defaultValue: (Ext.isOpera || Ext.isIE6) ? &#39;&amp;#160;&#39; : &#39;&amp;#8203;&#39;,

<span id='Ext-form-field-HtmlEditor-property-extraFieldBodyCls'>    // private
</span>    extraFieldBodyCls: Ext.baseCSSPrefix + &#39;html-editor-wrap&#39;,

<span id='Ext-form-field-HtmlEditor-cfg-defaultButtonUI'>    /**
</span>     * @cfg {String} defaultButtonUI
     * A default {@link Ext.Component#ui ui} to use for the HtmlEditor&#39;s toolbar
     * {@link Ext.button.Button Buttons}
     */

<span id='Ext-form-field-HtmlEditor-property-initialized'>    // @private
</span>    initialized: false,
<span id='Ext-form-field-HtmlEditor-property-activated'>    // @private
</span>    activated: false,
<span id='Ext-form-field-HtmlEditor-property-sourceEditMode'>    // @private
</span>    sourceEditMode: false,
<span id='Ext-form-field-HtmlEditor-property-iframePad'>    // @private
</span>    iframePad:3,
<span id='Ext-form-field-HtmlEditor-cfg-hideMode'>    // @private
</span>    hideMode:&#39;offsets&#39;,

<span id='Ext-form-field-HtmlEditor-property-maskOnDisable'>    maskOnDisable: true,
</span>
<span id='Ext-form-field-HtmlEditor-property-containerElCls'>    containerElCls: Ext.baseCSSPrefix + &#39;html-editor-container&#39;,
</span>
<span id='Ext-form-field-HtmlEditor-method-initComponent'>    // @private
</span>    initComponent: function(){
        var me = this;

        me.addEvents(
<span id='Ext-form-field-HtmlEditor-event-initialize'>            /**
</span>             * @event initialize
             * Fires when the editor is fully initialized (including the iframe)
             * @param {Ext.form.field.HtmlEditor} this
             */
            &#39;initialize&#39;,
<span id='Ext-form-field-HtmlEditor-event-activate'>            /**
</span>             * @event activate
             * Fires when the editor is first receives the focus. Any insertion must wait until after this event.
             * @param {Ext.form.field.HtmlEditor} this
             */
            &#39;activate&#39;,
<span id='Ext-form-field-HtmlEditor-event-beforesync'>             /**
</span>             * @event beforesync
             * Fires before the textarea is updated with content from the editor iframe. Return false to cancel the
             * sync.
             * @param {Ext.form.field.HtmlEditor} this
             * @param {String} html
             */
            &#39;beforesync&#39;,
<span id='Ext-form-field-HtmlEditor-event-beforepush'>             /**
</span>             * @event beforepush
             * Fires before the iframe editor is updated with content from the textarea. Return false to cancel the
             * push.
             * @param {Ext.form.field.HtmlEditor} this
             * @param {String} html
             */
            &#39;beforepush&#39;,
<span id='Ext-form-field-HtmlEditor-event-sync'>             /**
</span>             * @event sync
             * Fires when the textarea is updated with content from the editor iframe.
             * @param {Ext.form.field.HtmlEditor} this
             * @param {String} html
             */
            &#39;sync&#39;,
<span id='Ext-form-field-HtmlEditor-event-push'>             /**
</span>             * @event push
             * Fires when the iframe editor is updated with content from the textarea.
             * @param {Ext.form.field.HtmlEditor} this
             * @param {String} html
             */
            &#39;push&#39;,
<span id='Ext-form-field-HtmlEditor-event-editmodechange'>             /**
</span>             * @event editmodechange
             * Fires when the editor switches edit modes
             * @param {Ext.form.field.HtmlEditor} this
             * @param {Boolean} sourceEdit True if source edit, false if standard editing.
             */
            &#39;editmodechange&#39;
        );

        me.items = [me.createToolbar(), me.createInputCmp()];

        me.layout = {
            type: &#39;vbox&#39;,
            align: &#39;stretch&#39;
        };

        me.callParent(arguments);
        me.initField();
    },
    
<span id='Ext-form-field-HtmlEditor-method-createInputCmp'>    createInputCmp: function(){
</span>        this.inputCmp = Ext.widget(this.getInputCmpCfg());
        return this.inputCmp;
    },
    
<span id='Ext-form-field-HtmlEditor-method-getInputCmpCfg'>    getInputCmpCfg: function(){
</span>        var me = this,
            id = me.id + &#39;-inputCmp&#39;,
            data = {
                id          : id,
                name        : me.name,
                textareaCls : Ext.baseCSSPrefix + &#39;hidden&#39;,
                value       : me.value,
                iframeName  : Ext.id(),
                iframeSrc   : Ext.SSL_SECURE_URL,
                iframeCls   : Ext.baseCSSPrefix + &#39;htmleditor-iframe&#39;
            };
            
        me.getInsertionRenderData(data, me.subTplInsertions);
            
        return {
            flex: 1,
            xtype: &#39;component&#39;,
            tpl: me.getTpl(&#39;componentTpl&#39;),
            childEls: [&#39;iframeEl&#39;, &#39;textareaEl&#39;],
            id: id, 
            cls: Ext.baseCSSPrefix + &#39;html-editor-input&#39;,
            data: data 
        };    
    },

<span id='Ext-form-field-HtmlEditor-method-createToolbar'>    /*
</span>     * Called when the editor creates its toolbar. Override this method if you need to
     * add custom toolbar buttons.
     * @param {Ext.form.field.HtmlEditor} editor
     * @protected
     */
    createToolbar: function(){
        this.toolbar = Ext.widget(this.getToolbarCfg());
        return this.toolbar;
    },
    
<span id='Ext-form-field-HtmlEditor-method-getToolbarCfg'>    getToolbarCfg: function(){
</span>        var me = this,
            items = [], i,
            tipsEnabled = Ext.quickTipsActive &amp;&amp; Ext.tip.QuickTipManager.isEnabled(),
            baseCSSPrefix = Ext.baseCSSPrefix,
            fontSelectItem, undef;

        function btn(id, toggle, handler){
            return {
                itemId: id,
                cls: baseCSSPrefix + &#39;btn-icon&#39;,
                iconCls: baseCSSPrefix + &#39;edit-&#39;+id,
                enableToggle:toggle !== false,
                scope: me,
                handler:handler||me.relayBtnCmd,
                clickEvent: &#39;mousedown&#39;,
                tooltip: tipsEnabled ? me.buttonTips[id] || undef : undef,
                overflowText: me.buttonTips[id].title || undef,
                tabIndex: -1
            };
        }


        if (me.enableFont &amp;&amp; !Ext.isSafari2) {
            fontSelectItem = Ext.widget(&#39;component&#39;, {
                itemId: &#39;fontSelect&#39;,
                renderTpl: [
                    &#39;&lt;select id=&quot;{id}-selectEl&quot; class=&quot;&#39; + baseCSSPrefix + &#39;font-select&quot;&gt;&#39;,
                    &#39;&lt;/select&gt;&#39;
                ],
                childEls: [&#39;selectEl&#39;],
                afterRender: function() {
                    me.fontSelect = this.selectEl;
                    Ext.Component.prototype.afterRender.apply(this, arguments);
                },
                onDisable: function() {
                    var selectEl = this.selectEl;
                    if (selectEl) {
                        selectEl.dom.disabled = true;
                    }
                    Ext.Component.prototype.onDisable.apply(this, arguments);
                },
                onEnable: function() {
                    var selectEl = this.selectEl;
                    if (selectEl) {
                        selectEl.dom.disabled = false;
                    }
                    Ext.Component.prototype.onEnable.apply(this, arguments);
                },
                listeners: {
                    change: function() {
                        me.win.focus();
                        me.relayCmd(&#39;fontName&#39;, me.fontSelect.dom.value);
                        me.deferFocus();
                    },
                    element: &#39;selectEl&#39;
                }
            });

            items.push(
                fontSelectItem,
                &#39;-&#39;
            );
        }

        if (me.enableFormat) {
            items.push(
                btn(&#39;bold&#39;),
                btn(&#39;italic&#39;),
                btn(&#39;underline&#39;)
            );
        }

        if (me.enableFontSize) {
            items.push(
                &#39;-&#39;,
                btn(&#39;increasefontsize&#39;, false, me.adjustFont),
                btn(&#39;decreasefontsize&#39;, false, me.adjustFont)
            );
        }

        if (me.enableColors) {
            items.push(
                &#39;-&#39;, {
                    itemId: &#39;forecolor&#39;,
                    cls: baseCSSPrefix + &#39;btn-icon&#39;,
                    iconCls: baseCSSPrefix + &#39;edit-forecolor&#39;,
                    overflowText: me.buttonTips.forecolor.title,
                    tooltip: tipsEnabled ? me.buttonTips.forecolor || undef : undef,
                    tabIndex:-1,
                    menu: Ext.widget(&#39;menu&#39;, {
                        plain: true,

                        items: [{
                            xtype: &#39;colorpicker&#39;,
                            allowReselect: true,
                            focus: Ext.emptyFn,
                            value: &#39;000000&#39;,
                            plain: true,
                            clickEvent: &#39;mousedown&#39;,
                            handler: function(cp, color) {
                                me.relayCmd(&#39;forecolor&#39;, Ext.isWebKit || Ext.isIE ? &#39;#&#39;+color : color);
                                this.up(&#39;menu&#39;).hide();
                            }
                        }]
                    })
                }, {
                    itemId: &#39;backcolor&#39;,
                    cls: baseCSSPrefix + &#39;btn-icon&#39;,
                    iconCls: baseCSSPrefix + &#39;edit-backcolor&#39;,
                    overflowText: me.buttonTips.backcolor.title,
                    tooltip: tipsEnabled ? me.buttonTips.backcolor || undef : undef,
                    tabIndex:-1,
                    menu: Ext.widget(&#39;menu&#39;, {
                        plain: true,

                        items: [{
                            xtype: &#39;colorpicker&#39;,
                            focus: Ext.emptyFn,
                            value: &#39;FFFFFF&#39;,
                            plain: true,
                            allowReselect: true,
                            clickEvent: &#39;mousedown&#39;,
                            handler: function(cp, color) {
                                if (Ext.isGecko) {
                                    me.execCmd(&#39;useCSS&#39;, false);
                                    me.execCmd(&#39;hilitecolor&#39;, &#39;#&#39;+color);
                                    me.execCmd(&#39;useCSS&#39;, true);
                                    me.deferFocus();
                                } else {
                                    me.relayCmd(Ext.isOpera ? &#39;hilitecolor&#39; : &#39;backcolor&#39;, Ext.isWebKit || Ext.isIE || Ext.isOpera ? &#39;#&#39;+color : color);
                                }
                                this.up(&#39;menu&#39;).hide();
                            }
                        }]
                    })
                }
            );
        }

        if (me.enableAlignments) {
            items.push(
                &#39;-&#39;,
                btn(&#39;justifyleft&#39;),
                btn(&#39;justifycenter&#39;),
                btn(&#39;justifyright&#39;)
            );
        }

        if (!Ext.isSafari2) {
            if (me.enableLinks) {
                items.push(
                    &#39;-&#39;,
                    btn(&#39;createlink&#39;, false, me.createLink)
                );
            }

            if (me.enableLists) {
                items.push(
                    &#39;-&#39;,
                    btn(&#39;insertorderedlist&#39;),
                    btn(&#39;insertunorderedlist&#39;)
                );
            }
            if (me.enableSourceEdit) {
                items.push(
                    &#39;-&#39;,
                    btn(&#39;sourceedit&#39;, true, function(btn){
                        me.toggleSourceEdit(!me.sourceEditMode);
                    })
                );
            }
        }
        
        // Everything starts disabled.
        for (i = 0; i &lt; items.length; i++) {
            if (items[i].itemId !== &#39;sourceedit&#39;) {
                items[i].disabled = true;
            }
        }

        // build the toolbar
        // Automatically rendered in AbstractComponent.afterRender&#39;s renderChildren call
        return {
            xtype: &#39;toolbar&#39;,
            defaultButtonUI: me.defaultButtonUI,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tb&#39;,
            enableOverflow: true,
            items: items,

            // stop form submits
            listeners: {
                click: function(e){
                    e.preventDefault();
                },
                element: &#39;el&#39;
            }
        }; 
    },
    
<span id='Ext-form-field-HtmlEditor-method-getMaskTarget'>    getMaskTarget: function(){
</span>        // Can&#39;t be the body td directly because of issues with absolute positioning
        // inside td&#39;s in FF
        return Ext.isGecko ? this.inputCmp.el : this.bodyEl;
    },

<span id='Ext-form-field-HtmlEditor-method-setReadOnly'>    /**
</span>     * Sets the read only state of this field.
     * @param {Boolean} readOnly Whether the field should be read only.
     */
    setReadOnly: function(readOnly) {
        var me = this,
            textareaEl = me.textareaEl,
            iframeEl = me.iframeEl,
            body;

        me.readOnly = readOnly;

        if (textareaEl) {
            textareaEl.dom.readOnly = readOnly;
        }

        if (me.initialized) {
            body = me.getEditorBody();
            if (Ext.isIE) {
                // Hide the iframe while setting contentEditable so it doesn&#39;t grab focus
                iframeEl.setDisplayed(false);
                body.contentEditable = !readOnly;
                iframeEl.setDisplayed(true);
            } else {
                me.setDesignMode(!readOnly);
            }
            if (body) {
                body.style.cursor = readOnly ? &#39;default&#39; : &#39;text&#39;;
            }
            me.disableItems(readOnly);
        }
    },

<span id='Ext-form-field-HtmlEditor-method-getDocMarkup'>    /**
</span>     * Called when the editor initializes the iframe with HTML contents. Override this method if you
     * want to change the initialization markup of the iframe (e.g. to add stylesheets).
     *
     * **Note:** IE8-Standards has unwanted scroller behavior, so the default meta tag forces IE7 compatibility.
     * Also note that forcing IE7 mode works when the page is loaded normally, but if you are using IE&#39;s Web
     * Developer Tools to manually set the document mode, that will take precedence and override what this
     * code sets by default. This can be confusing when developing, but is not a user-facing issue.
     * @protected
     */
    getDocMarkup: function() {
        var me = this,
            h = me.iframeEl.getHeight() - me.iframePad * 2,
            oldIE = Ext.isIE8m;

        // - IE9+ require a strict doctype otherwise text outside visible area can&#39;t be selected.
        // - Opera inserts &lt;P&gt; tags on Return key, so P margins must be removed to avoid double line-height.
        // - On browsers other than IE, the font is not inherited by the IFRAME so it must be specified.
        return Ext.String.format(
            (oldIE ? &#39;&#39; : &#39;&lt;!DOCTYPE html&gt;&#39;)                        
            + &#39;&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;&#39; 
            + (Ext.isOpera ? &#39;p{margin:0}&#39; : &#39;&#39;)
            + &#39;body{border:0;margin:0;padding:{0}px;direction:&#39; + (me.rtl ? &#39;rtl;&#39; : &#39;ltr;&#39;)
            + (oldIE ? Ext.emptyString : &#39;min-&#39;)
            + &#39;height:{1}px;box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;cursor:text;background-color:white;&#39; 
            + (Ext.isIE ? &#39;&#39; : &#39;font-size:12px;font-family:{2}&#39;)
            + &#39;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#39;
            , me.iframePad, h, me.defaultFont);
    },

<span id='Ext-form-field-HtmlEditor-method-getEditorBody'>    // @private
</span>    getEditorBody: function() {
        var doc = this.getDoc();
        return doc.body || doc.documentElement;
    },

<span id='Ext-form-field-HtmlEditor-method-getDoc'>    // @private
</span>    getDoc: function() {
        return (!Ext.isIE &amp;&amp; this.iframeEl.dom.contentDocument) || this.getWin().document;
    },

<span id='Ext-form-field-HtmlEditor-method-getWin'>    // @private
</span>    getWin: function() {
        return Ext.isIE ? this.iframeEl.dom.contentWindow : window.frames[this.iframeEl.dom.name];
    },
    
<span id='Ext-form-field-HtmlEditor-method-initDefaultFont'>    initDefaultFont: function(){
</span>        // It&#39;s not ideal to do this here since it&#39;s a write phase, but we need to know
        // what the font used in the textarea is so that we can setup the appropriate font
        // options in the select box. The select box will reflow once we populate it, so we want
        // to do so before we layout the first time.
        
        var me = this,
            selIdx = 0,
            fonts, font, select,
            option, i, len, lower;
        
        if (!me.defaultFont) {
            font = me.textareaEl.getStyle(&#39;font-family&#39;);
            font = Ext.String.capitalize(font.split(&#39;,&#39;)[0]);
            fonts = Ext.Array.clone(me.fontFamilies);
            Ext.Array.include(fonts, font);
            fonts.sort();
            me.defaultFont = font;
            
            select = me.down(&#39;#fontSelect&#39;).selectEl.dom;
            for (i = 0, len = fonts.length; i &lt; len; ++i) {
                font = fonts[i];
                lower = font.toLowerCase();
                option = new Option(font, lower);
                if (font == me.defaultFont) {
                    selIdx = i;
                }
                option.style.fontFamily = lower;
                
                if (Ext.isIE) {
                    select.add(option);
                } else {
                    select.options.add(option); 
                }
            }
            // Old IE versions have a problem if we set the selected property
            // in the loop, so set it after.
            select.options[selIdx].selected = true;
        } 
    },
    
<span id='Ext-form-field-HtmlEditor-method-isEqual'>    isEqual: function(value1, value2){
</span>        return this.isEqualAsString(value1, value2);
    },

<span id='Ext-form-field-HtmlEditor-method-afterRender'>    // @private
</span>    afterRender: function() {
        var me = this,
            inputCmp = me.inputCmp;

        me.callParent(arguments);
          
        me.iframeEl = inputCmp.iframeEl;
        me.textareaEl = inputCmp.textareaEl;
        
        // The input element is interrogated by the layout to extract height when labelAlign is &#39;top&#39;
        // It must be set, and then switched between the iframe and the textarea
        me.inputEl = me.iframeEl;

        if (me.enableFont) {        
            me.initDefaultFont();
        }

        // Start polling for when the iframe document is ready to be manipulated
        me.monitorTask = Ext.TaskManager.start({
            run: me.checkDesignMode,
            scope: me,
            interval: 100
        });
        me.relayCmd(&#39;fontName&#39;, me.defaultFont);
    },

<span id='Ext-form-field-HtmlEditor-method-initFrameDoc'>    initFrameDoc: function() {
</span>        var me = this,
            doc, task;

        Ext.TaskManager.stop(me.monitorTask);

        doc = me.getDoc();
        me.win = me.getWin();

        doc.open();
        doc.write(me.getDocMarkup());
        doc.close();

        task = { // must defer to wait for browser to be ready
            run: function() {
                var doc = me.getDoc();
                if (doc.body || doc.readyState === &#39;complete&#39;) {
                    Ext.TaskManager.stop(task);
                    me.setDesignMode(true);
                    Ext.defer(me.initEditor, 10, me);
                }
            },
            interval: 10,
            duration:10000,
            scope: me
        };
        Ext.TaskManager.start(task);
    },

<span id='Ext-form-field-HtmlEditor-method-checkDesignMode'>    checkDesignMode: function() {
</span>        var me = this,
            doc = me.getDoc();
        if (doc &amp;&amp; (!doc.editorInitialized || me.getDesignMode() !== &#39;on&#39;)) {
            me.initFrameDoc();
        }
    },

<span id='Ext-form-field-HtmlEditor-method-setDesignMode'>    /**
</span>     * @private
     * Sets current design mode. To enable, mode can be true or &#39;on&#39;, off otherwise
     */
    setDesignMode: function(mode) {
        var me = this,
            doc = me.getDoc();
        if (doc) {
            if (me.readOnly) {
                mode = false;
            }
            doc.designMode = (/on|true/i).test(String(mode).toLowerCase()) ?&#39;on&#39;:&#39;off&#39;;
        }
    },

<span id='Ext-form-field-HtmlEditor-method-getDesignMode'>    // @private
</span>    getDesignMode: function() {
        var doc = this.getDoc();
        return !doc ? &#39;&#39; : String(doc.designMode).toLowerCase();
    },

<span id='Ext-form-field-HtmlEditor-method-disableItems'>    disableItems: function(disabled) {
</span>        var items = this.getToolbar().items.items,
            i,
            iLen  = items.length,
            item;

        for (i = 0; i &lt; iLen; i++) {
            item = items[i];

            if (item.getItemId() !== &#39;sourceedit&#39;) {
                item.setDisabled(disabled);
            }
        }
    },

<span id='Ext-form-field-HtmlEditor-method-toggleSourceEdit'>    /**
</span>     * Toggles the editor between standard and source edit mode.
     * @param {Boolean} [sourceEditMode] True for source edit, false for standard
     */
    toggleSourceEdit: function(sourceEditMode) {
        var me = this,
            iframe = me.iframeEl,
            textarea = me.textareaEl,
            hiddenCls = Ext.baseCSSPrefix + &#39;hidden&#39;,
            btn = me.getToolbar().getComponent(&#39;sourceedit&#39;);

        if (!Ext.isBoolean(sourceEditMode)) {
            sourceEditMode = !me.sourceEditMode;
        }
        me.sourceEditMode = sourceEditMode;

        if (btn.pressed !== sourceEditMode) {
            btn.toggle(sourceEditMode);
        }
        if (sourceEditMode) {
            me.disableItems(true);
            me.syncValue();
            iframe.addCls(hiddenCls);
            textarea.removeCls(hiddenCls);
            textarea.dom.removeAttribute(&#39;tabIndex&#39;);
            textarea.focus();
            me.inputEl = textarea;
        } else {
            if (me.initialized) {
                me.disableItems(me.readOnly);
            }
            me.pushValue();
            iframe.removeCls(hiddenCls);
            textarea.addCls(hiddenCls);
            textarea.dom.setAttribute(&#39;tabIndex&#39;, -1);
            me.deferFocus();
            me.inputEl = iframe;
        }
        me.fireEvent(&#39;editmodechange&#39;, me, sourceEditMode);
        me.updateLayout();
    },

<span id='Ext-form-field-HtmlEditor-method-createLink'>    // @private used internally
</span>    createLink: function() {
        var url = prompt(this.createLinkText, this.defaultLinkValue);
        if (url &amp;&amp; url !== &#39;http:/&#39;+&#39;/&#39;) {
            this.relayCmd(&#39;createlink&#39;, url);
        }
    },

<span id='Ext-form-field-HtmlEditor-method-clearInvalid'>    clearInvalid: Ext.emptyFn,
</span>
<span id='Ext-form-field-HtmlEditor-method-setValue'>    setValue: function(value) {
</span>        var me = this,
            textarea = me.textareaEl,
            inputCmp = me.inputCmp;
            
        me.mixins.field.setValue.call(me, value);
        if (value === null || value === undefined) {
            value = &#39;&#39;;
        }
        if (textarea) {
            textarea.dom.value = value;
        }
        me.pushValue();
        
        if (!me.rendered &amp;&amp; me.inputCmp) {
            me.inputCmp.data.value = value;
        }
        
        return me;
    },

<span id='Ext-form-field-HtmlEditor-method-cleanHtml'>    /**
</span>     * If you need/want custom HTML cleanup, this is the method you should override.
     * @param {String} html The HTML to be cleaned
     * @return {String} The cleaned HTML
     * @protected
     */
    cleanHtml: function(html) {
        html = String(html);
        if (Ext.isWebKit) { // strip safari nonsense
            html = html.replace(/\sclass=&quot;(?:Apple-style-span|Apple-tab-span|khtml-block-placeholder)&quot;/gi, &#39;&#39;);
        }

        /*
         * Neat little hack. Strips out all the non-digit characters from the default
         * value and compares it to the character code of the first character in the string
         * because it can cause encoding issues when posted to the server. We need the
         * parseInt here because charCodeAt will return a number.
         */
        if (html.charCodeAt(0) === parseInt(this.defaultValue.replace(/\D/g, &#39;&#39;), 10)) {
            html = html.substring(1);
        }
        
        return html;
    },

<span id='Ext-form-field-HtmlEditor-method-syncValue'>    /**
</span>     * Syncs the contents of the editor iframe with the textarea.
     * @protected
     */
    syncValue: function(){
        var me = this,
            body, changed, html, bodyStyle, match, textElDom;

        if (me.initialized) {
            body = me.getEditorBody();
            html = body.innerHTML;
            textElDom = me.textareaEl.dom;
            
            if (Ext.isWebKit) {
                bodyStyle = body.getAttribute(&#39;style&#39;); // Safari puts text-align styles on the body element!
                match = bodyStyle.match(/text-align:(.*?);/i);
                if (match &amp;&amp; match[1]) {
                    html = &#39;&lt;div style=&quot;&#39; + match[0] + &#39;&quot;&gt;&#39; + html + &#39;&lt;/div&gt;&#39;;
                }
            }
            
            html = me.cleanHtml(html);
            
            if (me.fireEvent(&#39;beforesync&#39;, me, html) !== false) {
                // Gecko inserts single &lt;br&gt; tag when input is empty
                // and user toggles source mode. See https://sencha.jira.com/browse/EXTJSIV-8542
                if (Ext.isGecko &amp;&amp; textElDom.value === &#39;&#39; &amp;&amp; html === &#39;&lt;br&gt;&#39;) {
                    html = &#39;&#39;;
                }
                
                if (textElDom.value !== html) {
                    textElDom.value = html;
                    changed = true;
                }

                me.fireEvent(&#39;sync&#39;, me, html);

                if (changed) {
                    // we have to guard this to avoid infinite recursion because getValue
                    // calls this method...
                    me.checkChange();
                }
            }
        }
    },

<span id='Ext-form-field-HtmlEditor-method-getValue'>    getValue: function() {
</span>        var me = this,
            value;
        if (!me.sourceEditMode) {
            me.syncValue();
        }
        value = me.rendered ? me.textareaEl.dom.value : me.value;
        me.value = value;
        return value;
    },

<span id='Ext-form-field-HtmlEditor-method-pushValue'>    /**
</span>     * Pushes the value of the textarea into the iframe editor.
     * @protected
     */
    pushValue: function() {
        var me = this,
            v;
        if(me.initialized){
            v = me.textareaEl.dom.value || &#39;&#39;;
            if (!me.activated &amp;&amp; v.length &lt; 1) {
                v = me.defaultValue;
            }
            if (me.fireEvent(&#39;beforepush&#39;, me, v) !== false) {
                me.getEditorBody().innerHTML = v;
                if (Ext.isGecko) {
                    // Gecko hack, see: https://bugzilla.mozilla.org/show_bug.cgi?id=232791#c8
                    me.setDesignMode(false);  //toggle off first
                    me.setDesignMode(true);
                }
                me.fireEvent(&#39;push&#39;, me, v);
            }
        }
    },

<span id='Ext-form-field-HtmlEditor-method-deferFocus'>    // @private
</span>    deferFocus: function(){
         this.focus(false, true);
    },

<span id='Ext-form-field-HtmlEditor-method-getFocusEl'>    getFocusEl: function() {
</span>        var me = this,
            win = me.win;
        return win &amp;&amp; !me.sourceEditMode ? win : me.textareaEl;
    },

<span id='Ext-form-field-HtmlEditor-method-focus'>    focus: function(selectText, delay) {
</span>        var me = this,
            value, focusEl;

        if (delay) {
            if (!me.focusTask) {
                me.focusTask = new Ext.util.DelayedTask(me.focus);
            }
            me.focusTask.delay(Ext.isNumber(delay) ? delay : 10, null, me, [selectText, false]);
        }
        else {
            if (selectText) {
                if (me.textareaEl &amp;&amp; me.textareaEl.dom) {
                    value = me.textareaEl.dom.value;
                }
                if (value &amp;&amp; value.length) {  // Make sure there is content before calling SelectAll, otherwise the caret disappears.
                    me.execCmd(&#39;selectall&#39;, true);
                }
            }
            focusEl = me.getFocusEl();
            if (focusEl &amp;&amp; focusEl.focus) {
                focusEl.focus();
            }
        }
        return me;
    },

<span id='Ext-form-field-HtmlEditor-method-initEditor'>    // @private
</span>    initEditor: function(){
        //Destroying the component during/before initEditor can cause issues.
        try {
            var me = this,
                dbody = me.getEditorBody(),
                ss = me.textareaEl.getStyles(&#39;font-size&#39;, &#39;font-family&#39;, &#39;background-image&#39;, &#39;background-repeat&#39;, &#39;background-color&#39;, &#39;color&#39;),
                doc,
                fn;

            ss[&#39;background-attachment&#39;] = &#39;fixed&#39;; // w3c
            dbody.bgProperties = &#39;fixed&#39;; // ie

            Ext.DomHelper.applyStyles(dbody, ss);

            doc = me.getDoc();

            if (doc) {
                try {
                    Ext.EventManager.removeAll(doc);
                } catch(e) {}
            }

            /*
             * We need to use createDelegate here, because when using buffer, the delayed task is added
             * as a property to the function. When the listener is removed, the task is deleted from the function.
             * Since onEditorEvent is shared on the prototype, if we have multiple html editors, the first time one of the editors
             * is destroyed, it causes the fn to be deleted from the prototype, which causes errors. Essentially, we&#39;re just anonymizing the function.
             */
            fn = Ext.Function.bind(me.onEditorEvent, me);
            Ext.EventManager.on(doc, {
                mousedown: fn,
                dblclick: fn,
                click: fn,
                keyup: fn,
                buffer:100
            });
            
            // These events need to be relayed from the inner document (where they stop
            // bubbling) up to the outer document. This has to be done at the DOM level so
            // the event reaches listeners on elements like the document body. The effected
            // mechanisms that depend on this bubbling behavior are listed to the right
            // of the event.
            fn = me.onRelayedEvent;
            Ext.EventManager.on(doc, {
                mousedown: fn, // menu dismisal (MenuManager) and Window onMouseDown (toFront)
                mousemove: fn, // window resize drag detection
                mouseup: fn,   // window resize termination
                click: fn,     // not sure, but just to be safe
                dblclick: fn,  // not sure again
                scope: me
            });
            
            if (Ext.isGecko) {
                Ext.EventManager.on(doc, &#39;keypress&#39;, me.applyCommand, me);
            }
            
            if (me.fixKeys) {
                Ext.EventManager.on(doc, &#39;keydown&#39;, me.fixKeys, me);
            }
            if (me.fixKeysAfter) {
                Ext.EventManager.on(doc, &#39;keyup&#39;, me.fixKeysAfter, me);
            }

            if (Ext.isIE9 &amp;&amp; Ext.isStrict) {
                Ext.EventManager.on(doc.documentElement, &#39;focus&#39;, me.focus, me);
            }

            // In old IEs, clicking on a toolbar button shifts focus from iframe
            // and it loses selection. To avoid this, we save current selection
            // and restore it.
            if (Ext.isIE8m || (Ext.isIE9 &amp;&amp; !Ext.isStrict)) {
                Ext.EventManager.on(doc, &#39;focusout&#39;, function() {
                    me.savedSelection = doc.selection.type !== &#39;None&#39; ? doc.selection.createRange() : null;
                }, me);
                
                Ext.EventManager.on(doc, &#39;focusin&#39;, function() {
                    if (me.savedSelection) {
                        me.savedSelection.select();
                    }
                }, me);
            }
            
            // We need to be sure we remove all our events from the iframe on unload or we&#39;re going to LEAK!
            Ext.EventManager.onWindowUnload(me.beforeDestroy, me);
            doc.editorInitialized = true;

            me.initialized = true;
            me.pushValue();
            me.setReadOnly(me.readOnly);
            me.fireEvent(&#39;initialize&#39;, me);
        } catch(ex) {
            // ignore (why?)
        }
    },
    
<span id='Ext-form-field-HtmlEditor-method-beforeDestroy'>    // @private
</span>    beforeDestroy: function(){
        var me = this,
            monitorTask = me.monitorTask,
            doc, prop;

        if (monitorTask) {
            Ext.TaskManager.stop(monitorTask);
        }
        if (me.rendered) {
            Ext.EventManager.removeUnloadListener(me.beforeDestroy, me);
            try {
                doc = me.getDoc();
                if (doc) {
                    // removeAll() doesn&#39;t currently know how to handle iframe document,
                    // so for now we have to wrap it in an Ext.Element using Ext.fly,
                    // or else IE6/7 will leak big time when the page is refreshed.
                    // TODO: this may not be needed once we find a more permanent fix.
                    // see EXTJSIV-5891.
                    Ext.EventManager.removeAll(Ext.fly(doc));
                    for (prop in doc) {
                        if (doc.hasOwnProperty &amp;&amp; doc.hasOwnProperty(prop)) {
                            delete doc[prop];
                        }
                    }
                }
            } catch(e) {
                // ignore (why?)
            }
            delete me.iframeEl;
            delete me.textareaEl;
            delete me.toolbar;
            delete me.inputCmp;
        }
        me.callParent();
    },

<span id='Ext-form-field-HtmlEditor-method-onRelayedEvent'>    // @private
</span>    onRelayedEvent: function (event) {
        // relay event from the iframe&#39;s document to the document that owns the iframe...

        var iframeEl = this.iframeEl,

            // Get the left-based iframe position
            iframeXY = Ext.Element.getTrueXY(iframeEl),
            originalEventXY = event.getXY(),

            // Get the left-based XY position.
            // This is because the consumer of the injected event (Ext.EventManager) will
            // perform its own RTL normalization.
            eventXY = Ext.EventManager.getPageXY(event.browserEvent);

        // the event from the inner document has XY relative to that document&#39;s origin,
        // so adjust it to use the origin of the iframe in the outer document:
        event.xy = [iframeXY[0] + eventXY[0], iframeXY[1] + eventXY[1]];

        event.injectEvent(iframeEl); // blame the iframe for the event...

        event.xy = originalEventXY; // restore the original XY (just for safety)
    },

<span id='Ext-form-field-HtmlEditor-method-onFirstFocus'>    // @private
</span>    onFirstFocus: function(){
        var me = this,
            selection, range;
        me.activated = true;
        me.disableItems(me.readOnly);
        if (Ext.isGecko) { // prevent silly gecko errors
            me.win.focus();
            selection = me.win.getSelection();
            if (!selection.focusNode || selection.focusNode.nodeType !== 3) {
                range = selection.getRangeAt(0);
                range.selectNodeContents(me.getEditorBody());
                range.collapse(true);
                me.deferFocus();
            }
            try {
                me.execCmd(&#39;useCSS&#39;, true);
                me.execCmd(&#39;styleWithCSS&#39;, false);
            } catch(e) {
                // ignore (why?)
            }
        }
        me.fireEvent(&#39;activate&#39;, me);
    },

<span id='Ext-form-field-HtmlEditor-method-adjustFont'>    // @private
</span>    adjustFont: function(btn) {
        var adjust = btn.getItemId() === &#39;increasefontsize&#39; ? 1 : -1,
            size = this.getDoc().queryCommandValue(&#39;FontSize&#39;) || &#39;2&#39;,
            isPxSize = Ext.isString(size) &amp;&amp; size.indexOf(&#39;px&#39;) !== -1,
            isSafari;
        size = parseInt(size, 10);
        if (isPxSize) {
            // Safari 3 values
            // 1 = 10px, 2 = 13px, 3 = 16px, 4 = 18px, 5 = 24px, 6 = 32px
            if (size &lt;= 10) {
                size = 1 + adjust;
            }
            else if (size &lt;= 13) {
                size = 2 + adjust;
            }
            else if (size &lt;= 16) {
                size = 3 + adjust;
            }
            else if (size &lt;= 18) {
                size = 4 + adjust;
            }
            else if (size &lt;= 24) {
                size = 5 + adjust;
            }
            else {
                size = 6 + adjust;
            }
            size = Ext.Number.constrain(size, 1, 6);
        } else {
            isSafari = Ext.isSafari;
            if (isSafari) { // safari
                adjust *= 2;
            }
            size = Math.max(1, size + adjust) + (isSafari ? &#39;px&#39; : 0);
        }
        this.relayCmd(&#39;FontSize&#39;, size);
    },

<span id='Ext-form-field-HtmlEditor-method-onEditorEvent'>    // @private
</span>    onEditorEvent: function(e) {
        this.updateToolbar();
    },

<span id='Ext-form-field-HtmlEditor-method-updateToolbar'>    /**
</span>     * Triggers a toolbar update by reading the markup state of the current selection in the editor.
     * @protected
     */
    updateToolbar: function() {
        var me = this,
            i, l, btns, doc, name, queriedName, fontSelect,
            toolbarSubmenus;

        if (me.readOnly) {
            return;
        }

        if (!me.activated) {
            me.onFirstFocus();
            return;
        }

        btns = me.getToolbar().items.map;
        doc = me.getDoc();

        if (me.enableFont &amp;&amp; !Ext.isSafari2) {
            // When querying the fontName, Chrome may return an Array of font names
            // with those containing spaces being placed between single-quotes.
            queriedName = doc.queryCommandValue(&#39;fontName&#39;);
            name = (queriedName ? queriedName.split(&quot;,&quot;)[0].replace(/^&#39;/,&#39;&#39;).replace(/&#39;$/,&#39;&#39;) : me.defaultFont).toLowerCase();
            fontSelect = me.fontSelect.dom;
            if (name !== fontSelect.value || name != queriedName) {
                fontSelect.value = name;
            }
        }

        function updateButtons() {
            var state;
            
            for (i = 0, l = arguments.length, name; i &lt; l; i++) {
                name  = arguments[i];
                
                // Firefox 18+ sometimes throws NS_ERROR_INVALID_POINTER exception
                // See https://sencha.jira.com/browse/EXTJSIV-9766
                try {
                    state = doc.queryCommandState(name);
                }
                catch (e) {
                    state = false;
                }
                
                btns[name].toggle(state);
            }
        }
        if(me.enableFormat){
            updateButtons(&#39;bold&#39;, &#39;italic&#39;, &#39;underline&#39;);
        }
        if(me.enableAlignments){
            updateButtons(&#39;justifyleft&#39;, &#39;justifycenter&#39;, &#39;justifyright&#39;);
        }
        if(!Ext.isSafari2 &amp;&amp; me.enableLists){
            updateButtons(&#39;insertorderedlist&#39;, &#39;insertunorderedlist&#39;);
        }

        // Ensure any of our toolbar&#39;s owned menus are hidden.
        // The overflow menu must control itself.
        toolbarSubmenus = me.toolbar.query(&#39;menu&#39;);
        for (i = 0; i &lt; toolbarSubmenus.length; i++) {
            toolbarSubmenus[i].hide();
        }
        me.syncValue();
    },

<span id='Ext-form-field-HtmlEditor-method-relayBtnCmd'>    // @private
</span>    relayBtnCmd: function(btn) {
        this.relayCmd(btn.getItemId());
    },

<span id='Ext-form-field-HtmlEditor-method-relayCmd'>    /**
</span>     * Executes a Midas editor command on the editor document and performs necessary focus and toolbar updates.
     * **This should only be called after the editor is initialized.**
     * @param {String} cmd The Midas command
     * @param {String/Boolean} [value=null] The value to pass to the command
     */
    relayCmd: function(cmd, value) {
        Ext.defer(function() {
            var me = this;
            
            if (!this.isDestroyed) {
                me.win.focus();
                me.execCmd(cmd, value);
                me.updateToolbar();
            }
        }, 10, this);
    },

<span id='Ext-form-field-HtmlEditor-method-execCmd'>    /**
</span>     * Executes a Midas editor command directly on the editor document. For visual commands, you should use
     * {@link #relayCmd} instead. **This should only be called after the editor is initialized.**
     * @param {String} cmd The Midas command
     * @param {String/Boolean} [value=null] The value to pass to the command
     */
    execCmd: function(cmd, value){
        var me = this,
            doc = me.getDoc();
        doc.execCommand(cmd, false, (value == undefined ? null : value));
        me.syncValue();
    },

<span id='Ext-form-field-HtmlEditor-method-applyCommand'>    // @private
</span>    applyCommand: function(e){
        if (e.ctrlKey) {
            var me = this,
                c = e.getCharCode(), cmd;
            if (c &gt; 0) {
                c = String.fromCharCode(c);
                switch (c) {
                    case &#39;b&#39;:
                        cmd = &#39;bold&#39;;
                    break;
                    case &#39;i&#39;:
                        cmd = &#39;italic&#39;;
                    break;
                    case &#39;u&#39;:
                        cmd = &#39;underline&#39;;
                    break;
                }
                if (cmd) {
                    me.win.focus();
                    me.execCmd(cmd);
                    me.deferFocus();
                    e.preventDefault();
                }
            }
        }
    },

<span id='Ext-form-field-HtmlEditor-method-insertAtCursor'>    /**
</span>     * Inserts the passed text at the current cursor position.
     * __Note:__ the editor must be initialized and activated to insert text.
     * @param {String} text
     */
    insertAtCursor: function(text){
        var me = this,
            range;

        if (me.activated) {
            me.win.focus();
            if (Ext.isIE) {
                range = me.getDoc().selection.createRange();
                if (range) {
                    range.pasteHTML(text);
                    me.syncValue();
                    me.deferFocus();
                }
            }else{
                me.execCmd(&#39;InsertHTML&#39;, text);
                me.deferFocus();
            }
        }
    },

<span id='Ext-form-field-HtmlEditor-property-fixKeys'>    // @private
</span>    fixKeys: (function() { // load time branching for fastest keydown performance
        if (Ext.isIE) {
            return function(e){
                var me = this,
                    k = e.getKey(),
                    doc = me.getDoc(),
                    readOnly = me.readOnly,
                    range, target;

                if (k === e.TAB) {
                    e.stopEvent();
                    if (!readOnly) {
                        range = doc.selection.createRange();
                        if (range){
                            if (range.collapse) {
                                range.collapse(true);
                                range.pasteHTML(&#39;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&#39;);
                            }
                            
                            me.deferFocus();
                        }
                    }
                }
                else if (k === e.ENTER) {
                    if (!readOnly) {
                        range = doc.selection.createRange();
                        if (range) {
                            target = range.parentElement();
                            if(!target || target.tagName.toLowerCase() !== &#39;li&#39;){
                                e.stopEvent();
                                range.pasteHTML(&#39;&lt;br /&gt;&#39;);
                                range.collapse(false);
                                range.select();
                            }
                        }
                    }
                }
            };
        }

        if (Ext.isOpera) {
            return function(e){
                var me = this,
                    k = e.getKey(),
                    readOnly = me.readOnly;
                if (k === e.TAB) {
                    e.stopEvent();
                    if (!readOnly) {
                        me.win.focus();
                        me.execCmd(&#39;InsertHTML&#39;,&#39;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&#39;);
                        me.deferFocus();
                    }
                }
            };
        }

        return null; // not needed, so null
    }()),
    
<span id='Ext-form-field-HtmlEditor-property-fixKeysAfter'>    // @private
</span>    fixKeysAfter: (function() {
        if (Ext.isIE) {
            return function(e) {
                var me = this,
                    k = e.getKey(),
                    doc = me.getDoc(),
                    readOnly = me.readOnly,
                    innerHTML;
                
                if (!readOnly &amp;&amp; (k === e.BACKSPACE || k === e.DELETE)) {
                    innerHTML = doc.body.innerHTML;
                    
                    // If HtmlEditor had some input and user cleared it, IE inserts &lt;p&gt;&amp;nbsp;&lt;/p&gt;
                    // which makes an impression that there is still some text, and creeps
                    // into source mode when toggled. We don&#39;t want this.
                    //
                    // See https://sencha.jira.com/browse/EXTJSIV-8542
                    // 
                    // N.B. There is **small** chance that user could go to source mode,
                    // type &#39;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&#39;, switch back to visual mode, type something else
                    // and then clear it -- the code below would clear the &lt;p&gt; tag as well,
                    // which could be considered a bug. However I see no way to distinguish
                    // between offending markup being entered manually and generated by IE,
                    // so this can be considered a nasty corner case.
                    //
                    if (innerHTML === &#39;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&#39; || innerHTML === &#39;&lt;P&gt;&amp;nbsp;&lt;/P&gt;&#39;) {
                        doc.body.innerHTML = &#39;&#39;;
                    }
                }
            }
        }
        
        return null;
    }()),

<span id='Ext-form-field-HtmlEditor-method-getToolbar'>    /**
</span>     * Returns the editor&#39;s toolbar. **This is only available after the editor has been rendered.**
     * @return {Ext.toolbar.Toolbar}
     */
    getToolbar: function(){
        return this.toolbar;
    },

    //&lt;locale&gt;
<span id='Ext-form-field-HtmlEditor-property-buttonTips'>    /**
</span>     * @property {Object} buttonTips
     * Object collection of toolbar tooltips for the buttons in the editor. The key is the command id associated with
     * that button and the value is a valid QuickTips object. For example:
     *
     *     {
     *         bold: {
     *             title: &#39;Bold (Ctrl+B)&#39;,
     *             text: &#39;Make the selected text bold.&#39;,
     *             cls: &#39;x-html-editor-tip&#39;
     *         },
     *         italic: {
     *             title: &#39;Italic (Ctrl+I)&#39;,
     *             text: &#39;Make the selected text italic.&#39;,
     *             cls: &#39;x-html-editor-tip&#39;
     *         }
     *         // ...
     *     }
     */
    buttonTips: {
        bold: {
            title: &#39;Bold (Ctrl+B)&#39;,
            text: &#39;Make the selected text bold.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        italic: {
            title: &#39;Italic (Ctrl+I)&#39;,
            text: &#39;Make the selected text italic.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        underline: {
            title: &#39;Underline (Ctrl+U)&#39;,
            text: &#39;Underline the selected text.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        increasefontsize: {
            title: &#39;Grow Text&#39;,
            text: &#39;Increase the font size.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        decreasefontsize: {
            title: &#39;Shrink Text&#39;,
            text: &#39;Decrease the font size.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        backcolor: {
            title: &#39;Text Highlight Color&#39;,
            text: &#39;Change the background color of the selected text.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        forecolor: {
            title: &#39;Font Color&#39;,
            text: &#39;Change the color of the selected text.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        justifyleft: {
            title: &#39;Align Text Left&#39;,
            text: &#39;Align text to the left.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        justifycenter: {
            title: &#39;Center Text&#39;,
            text: &#39;Center text in the editor.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        justifyright: {
            title: &#39;Align Text Right&#39;,
            text: &#39;Align text to the right.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        insertunorderedlist: {
            title: &#39;Bullet List&#39;,
            text: &#39;Start a bulleted list.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        insertorderedlist: {
            title: &#39;Numbered List&#39;,
            text: &#39;Start a numbered list.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        createlink: {
            title: &#39;Hyperlink&#39;,
            text: &#39;Make the selected text a hyperlink.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        sourceedit: {
            title: &#39;Source Edit&#39;,
            text: &#39;Switch to source editing mode.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        }
    }
    //&lt;/locale&gt;

    // hide stuff that is not compatible
<span id='Ext-form-field-HtmlEditor-event-blur'>    /**
</span>     * @event blur
     * @private
     */
<span id='Ext-form-field-HtmlEditor-event-focus'>    /**
</span>     * @event focus
     * @private
     */
<span id='Ext-form-field-HtmlEditor-event-specialkey'>    /**
</span>     * @event specialkey
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-fieldCls'>    /**
</span>     * @cfg {String} fieldCls
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-focusCls'>    /**
</span>     * @cfg {String} focusCls
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-autoCreate'>    /**
</span>     * @cfg {String} autoCreate
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-inputType'>    /**
</span>     * @cfg {String} inputType
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-invalidCls'>    /**
</span>     * @cfg {String} invalidCls
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-invalidText'>    /**
</span>     * @cfg {String} invalidText
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-msgFx'>    /**
</span>     * @cfg {String} msgFx
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-allowDomMove'>    /**
</span>     * @cfg {Boolean} allowDomMove
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-applyTo'>    /**
</span>     * @cfg {String} applyTo
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-readOnly'>    /**
</span>     * @cfg {String} readOnly
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-tabIndex'>    /**
</span>     * @cfg {String} tabIndex
     * @private
     */
<span id='Ext-form-field-HtmlEditor-method-validate'>    /**
</span>     * @method validate
     * @private
     */
});
</pre>
</body>
</html>

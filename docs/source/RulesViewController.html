<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-RulesViewController'>/**
</span> * A ViewController to the GXC.panel.Rules panel.
 * @type {String}
 */
Ext.define(&#39;GXC.panel.RulesViewController&#39;, {
    extend: &#39;Deft.mvc.ViewController&#39;,
    requires: [
        &#39;GXC.panel.Rule&#39;
    ],

    control: {
        &#39;view&#39;: {
            &#39;boxready&#39;: &#39;onViewBoxready&#39;
        },
        &#39;addButton&#39;: {
            &#39;click&#39;: &#39;onAddButtonClick&#39;
        },
        &#39;deleteButton&#39;: {
            &#39;click&#39;: &#39;onDeleteButtonClick&#39;
        },
        &#39;editButton&#39;: {
            &#39;click&#39;: &#39;onEditButtonClick&#39;
        },
        &#39;upButton&#39;: {
            &#39;click&#39;: &#39;onUpButtonClick&#39;
        },
        &#39;downButton&#39;: {
            &#39;click&#39;: &#39;onDownButtonClick&#39;
        },
        &#39;duplicateButton&#39;: {
            &#39;click&#39;: &#39;onDuplicateButtonClick&#39;
        },
        &#39;rulesFieldset&#39;: true,
        &#39;legend&#39;: {
            live: true,
            listeners: {
                &#39;ruleselected&#39;: &#39;onLegendRuleselected&#39;,
                &#39;ruleunselected&#39;: &#39;onLegendRuleunselected&#39;,
                &#39;rulemoved&#39;: &#39;onLegendRulemoved&#39;
            }
        }
    },

<span id='global-property-symbolType'>    /**
</span>     * The symbolType of the selected style.
     * @type {String}
     *
     * @private
     */
    symbolType: null,

<span id='global-property-selectedRule'>    /**
</span>     * The selected rule that actions are called upon.
     * @type {OpenLayers.Rule}
     *
     * @private
     */
    selectedRule: null,

    onViewBoxready: function() {
        this.createLegend();
    },

<span id='global-method-onAddButtonClick'>    /**
</span>     * @private
     */
    onAddButtonClick: function() {
        var view = this.getView(),
            style = view.layerStyle,
            legend = this.getLegend();

        style.get(&#39;userStyle&#39;).rules.push(
            this.createRule()
        );
        legend.update();
        // mark the style as modified if it is in a store
        if (style.store) {
            style.store.afterEdit(style);
        }
        this.updateRuleRemoveButton();
    },

<span id='global-method-onDeleteButtonClick'>    /**
</span>     * @private
     */
    onDeleteButtonClick: function() {
        var view = this.getView(),
            selectedRule = this.selectedRule,
            style = view.layerStyle;

        this.getLegend().unselect();
        Ext.Array.remove(style.get(&#39;userStyle&#39;).rules, selectedRule);
        // mark the style as modified
        this.afterRuleChange();
        view.fireEvent(&#39;styleupdated&#39;, view, style);
    },

    onEditButtonClick: function() {
        this.getLayerDescription()
        .then(this.editRule.bind(this))
        .fail(function() {
            console.log(arguments);
        }).done();
    },

    onUpButtonClick: function() {
        var legend = this.getLegend(),
            rules = this.getView().layerStyle.get(&#39;userStyle&#39;).rules,
            idx = Ext.Array.indexOf(rules, this.selectedRule);

        if (idx &gt; 0) {
            legend.moveRule(idx, idx - 1);
        }
    },

    onDownButtonClick: function() {
        var legend = this.getLegend(),
            rules = this.getView().layerStyle.get(&#39;userStyle&#39;).rules,
            idx = Ext.Array.indexOf(rules, this.selectedRule),
            maxIdx = rules.length - 1;

        if (idx &lt; maxIdx) {
            legend.moveRule(idx, idx + 1);
        }
    },

<span id='global-method-onDuplicateButtonClick'>    /** private: method[duplicateRule]
</span>     */
    onDuplicateButtonClick: function() {
        var view = this.getView(),
            layerStyle = view.layerStyle,
            legend = this.getLegend();
            newRule = this.selectedRule.clone();

        layerStyle.get(&#39;userStyle&#39;).rules.push(
            newRule
        );
        legend.update();
        // mark the style as modified
        if (layerStyle.store) {
            layerStyle.store.afterEdit(this.layerStyle);
        }
        this.updateRuleRemoveButton();
    },

    onLegendRuleselected: function(cmp, rule) {
        this.selectedRule = rule;
        // enable the Remove, Edit and Duplicate buttons
        this.updateRuleRemoveButton();
        this.getEditButton().enable();
        this.getUpButton().enable();
        this.getDownButton().enable();
        this.getDuplicateButton().enable();
    },

    onLegendRuleunselected: function(cmp, rule) {
        this.selectedRule = null;
        // disable the Remove, Edit and Duplicate buttons
        this.getDeleteButton().disable();
        this.getEditButton().disable();
        this.getUpButton().disable();
        this.getDownButton().disable();
        this.getDuplicateButton().disable();
    },

    onLegendRulemoved: function() {
        // this.markModified();
    },

    onLegendAfterlayout: function(legend) {
        // restore selection
        if (this.selectedRule !== null &amp;&amp;
            legend.selectedRule === null &amp;&amp;
            legend.rules.indexOf(this.selectedRule) !== -1) {
            legend.selectRuleEntry(this.selectedRule);
        }
    },

<span id='global-method-getLayerDescription'>    /**
</span>     * Gets the layers description if it is not cached locally yet.
     * Since this is an async method, a promise of the description is returned.
     * @return {Q.Promise} The promise of the layer description.
     */
    getLayerDescription: function() {
        var deferred = Q.defer(),
            view = this.getView(),
            desc = this._layerDescription,
            layerRecord = view.layerRecord,
            layer = layerRecord.getLayer(),
            version, inlineAttr = [];

        if (desc) {
            deferred.resolve(desc);
        } else if (layer.CLASS_NAME === &#39;OpenLayers.Layer.Vector&#39; &amp;&amp; layer.protocol) {
            // if a Wfs layer is to be described, all settings can be taken
            // from the layers protocol
            this._layerDescription = {
                layerName: layer.protocol.featureType,
                owsType: &quot;WFS&quot;,
                owsURL: layer.protocol.url,
                typeName: layer.protocol.featureType
            };
            deferred.resolve(this._layerDescription);
        } else if (layer.CLASS_NAME === &#39;OpenLayers.Layer.WMS&#39;) {
            // Wms layers may provide a DescribeLayer endpoint
            version = layer.params[&quot;VERSION&quot;];

            if (parseFloat(version) &gt; 1.1) {
                //TODO don&#39;t force 1.1.1, fall back instead
                version = &quot;1.1.1&quot;;
            }
            Ext.Ajax.request({
                url: layer.url,
                params: {
                    &quot;SERVICE&quot;: &quot;WMS&quot;,
                    &quot;VERSION&quot;: version,
                    &quot;REQUEST&quot;: &quot;DescribeLayer&quot;,
                    &quot;LAYERS&quot;: [layer.params[&quot;LAYERS&quot;]].join(&quot;,&quot;)
                },
                method: &quot;GET&quot;,
                disableCaching: false,
                success: function(response) {
                    var result = new OpenLayers.Format.WMSDescribeLayer().read(
                        response.responseXML &amp;&amp; response.responseXML.documentElement ?
                            response.responseXML : response.responseText);
                    this._layerDescription = result[0];
                    deferred.resolve(this._layerDescription);
                },
                scope: this
            });
        } else {
            // non WMS/WFS layer can not provide a layer description
            deferred.resolve();
        }

        return deferred.promise;
    },

<span id='global-method-editRule'>    /** private: method[editRule]
</span>     */
    editRule: function(layerDescription) {
        var view = this.getView(),
            layerRecord = view.layerRecord,
            layer = layerRecord.getLayer(),
            rule = this.selectedRule,
            desc = layerDescription,
            attributesStore, dialog;

        if (desc) {
            attributesStore = Ext.create(&#39;GeoExt.data.AttributeStore&#39;, {
                url: desc.owsURL,
                baseParams: {
                    &quot;SERVICE&quot;: desc.owsType,
                    &quot;REQUEST&quot;: &quot;DescribeFeatureType&quot;,
                    &quot;TYPENAME&quot;: desc.typeName
                },
                method: &quot;GET&quot;,
                disableCaching: false
            });
        }

        dialog = Ext.create(view.dialogCls, {
            title: Ext.String.format(view.ruleWindowTitle, rule.title ||
                    rule.name || view.newRuleText),
            shortTitle: rule.title || rule.name || view.newRuleText,
            layout: &#39;fit&#39;,
            width: 320,
            height: 450,
            modal: true,
            items: [{
                xtype: &#39;gxc_panel_rule&#39;,
                ref: &#39;rulePanel&#39;,
                simple: layer.CLASS_NAME === &#39;OpenLayers.Layer.Vector&#39;,
                symbolType: this.symbolType,
                attributes: attributesStore,
                rule: rule,
                autoScroll: true,
                border: false,
                defaults: {
                    autoHeight: true,
                    hideMode: &#39;offsets&#39;
                }
            }],
            bbar: [&#39;-&gt;&#39;, {
                text: view.cancelText,
                iconCls: &#39;cancel&#39;,
                handler: function() {
                    dialog.destroy();
                },
                scope: this
            }, {
                text: view.saveText,
                iconCls: &#39;save&#39;,
                handler: function() {
                    this.saveRule(dialog.rulePanel, rule);
                    dialog.destroy();
                },
                scope: this
            }],
            listeners: {
                &#39;close&#39;: function() {
                    dialog.destroy();
                },
                scope: this
            }
        });
        this.showDlg(dialog);
    },

<span id='global-method-updateRuleRemoveButton'>    /** private: method[updateRuleRemoveButton]
</span>     *  Enable/disable the &#39;Remove&#39; button to make sure that we don&#39;t delete
     *  the last rule.
     */
    updateRuleRemoveButton: function() {
        var btn = this.getDeleteButton();

        btn.setDisabled(!this.selectedRule || this.getLegend().rules.length &lt; 2);
    },

<span id='global-method-createRule'>    /** private: method[createRule]
</span>     */
    createRule: function() {
        var view = this.getView(),
            rules = view.layerStyle.get(&#39;userStyle&#39;).rules;

        if (rules.length &amp;&amp; rules[0].symbolizer) {
            return new OpenLayers.Rule({
                symbolizer: new OpenLayers.Symbolizer[this.symbolType]
            });
        } else {
            return new OpenLayers.Rule({
                symbolizers: [new OpenLayers.Symbolizer[this.symbolType]]
            });
        }
    },

<span id='global-method-saveRule'>    /**
</span>     * @param {OpenLayers.Rule} rule [description]
     */
    saveRule: function(cmp, rule) {
        var view = this.getView(),
            style = this.getView().layerStyle,
            userStyle = style.get(&#39;userStyle&#39;),
            i = Ext.Array.indexOf(userStyle.rules, this.selectedRule);

        userStyle.rules[i] = rule;

        // trigger edited status
        style.set(&#39;userStyle&#39;, userStyle);

        // update legend
        this.afterRuleChange(rule);

        // let the editor know about change
        view.fireEvent(&#39;styleupdated&#39;, view, style);
    },

<span id='global-method-afterRuleChange'>    /**
</span>     *  Performs actions that are required to update the selectedRule and
     *  layerStyle after a rule was changed.
     *  @param {OpenLayers.Rule} rule Rule to select. May be null.
     */
    afterRuleChange: function(rule) {
        var legend = this.getLegend();

        legend.selectRuleEntry(rule);
        this.selectedRule = rule;
        this.getLegend().update();
    },

<span id='global-method-createLegend'>    /**
</span>     * Creates legend description from array of rules.
     */
    createLegend: function() {
        var view = this.getView(),
            rules = view.layerStyle.get(&#39;userStyle&#39;).rules,
            R = OpenLayers.Symbolizer.Raster,
            symbolizer = rules[0].symbolizers ? rules[0].symbolizers[0] : rules[0].symbolizer;

        if (R &amp;&amp; symbolizer instanceof R) {
            throw new Error(&#39;Raster symbolizers are not supported.&#39;);
        } else {
            this.addVectorLegend(rules);
        }
    },

<span id='global-method-addVectorLegend'>    /**
</span>     *  :arg rules: ``Array``
     *  :arg options: ``Object``
     *  :return: ``GeoExt.VectorLegend`` the legend that was created
     *
     *  Creates the vector legend for the provided rules and adds it to the
     *  rules fieldset.
     *
     * @private
     */
    addVectorLegend: function(rules, options) {
        var typeHierarchy, highest;

        options = options || {};

        this.symbolType = options.symbolType;
        if (!this.symbolType &amp;&amp; rules.length) {
            typeHierarchy = [&quot;Point&quot;, &quot;Line&quot;, &quot;Polygon&quot;];
            // use the highest symbolizer type of the 1st rule
            highest = 0;
            var symbolizers = rules[0].symbolizers || [rules[0].symbolizer],
                symbolType;
            for (var i = symbolizers.length - 1; i &gt;= 0; i--) {
                symbolType = symbolizers[i].CLASS_NAME.split(&quot;.&quot;).pop();
                highest = Math.max(highest, typeHierarchy.indexOf(symbolType));
            }
            this.symbolType = typeHierarchy[highest];
        }

        return this.getRulesFieldset().add({
            xtype: &quot;gx_vectorlegend&quot;,
            itemId: &#39;legend&#39;,
            showTitle: false,
            border: false,
            height: rules.length &gt; 10 ? 250 : undefined,
            autoScroll: rules.length &gt; 10,
            rules: rules,
            symbolType: this.symbolType,
            selectOnClick: true
        });
    },

<span id='global-method-showDlg'>    /**
</span>     *
     */
    showDlg: function(dlg) {
        dlg.show();
    }
});
</pre>
</body>
</html>

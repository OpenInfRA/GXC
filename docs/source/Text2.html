<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
This file is part of Ext JS 4.2

Copyright (c) 2011-2013 Sencha Inc

Contact:  http://www.sencha.com/contact

GNU General Public License Usage
This file may be used under the terms of the GNU General Public License version 3.0 as
published by the Free Software Foundation and appearing in the file LICENSE included in the
packaging of this file.

Please review the following information to ensure the GNU General Public License version 3.0
requirements will be met: http://www.gnu.org/copyleft/gpl.html.

If you are unsure which license is appropriate for your use, please contact the sales department
at http://www.sencha.com/contact.

Build date: 2013-05-16 14:36:50 (f9be68accb407158ba2b1be2c226a6ce1f649314)
*/
<span id='Ext-form-field-Text'>/**
</span> * @docauthor Jason Johnston &lt;jason@sencha.com&gt;
 *
 * A basic text field.  Can be used as a direct replacement for traditional text inputs,
 * or as the base class for more sophisticated input controls (like {@link Ext.form.field.TextArea}
 * and {@link Ext.form.field.ComboBox}). Has support for empty-field placeholder values (see {@link #emptyText}).
 *
 * # Validation
 *
 * The Text field has a useful set of validations built in:
 *
 * - {@link #allowBlank} for making the field required
 * - {@link #minLength} for requiring a minimum value length
 * - {@link #maxLength} for setting a maximum value length (with {@link #enforceMaxLength} to add it
 *   as the `maxlength` attribute on the input element)
 * - {@link #regex} to specify a custom regular expression for validation
 *
 * In addition, custom validations may be added:
 *
 * - {@link #vtype} specifies a virtual type implementation from {@link Ext.form.field.VTypes} which can contain
 *   custom validation logic
 * - {@link #validator} allows a custom arbitrary function to be called during validation
 *
 * The details around how and when each of these validation options get used are described in the
 * documentation for {@link #getErrors}.
 *
 * By default, the field value is checked for validity immediately while the user is typing in the
 * field. This can be controlled with the {@link #validateOnChange}, {@link #checkChangeEvents}, and
 * {@link #checkChangeBuffer} configurations. Also see the details on Form Validation in the
 * {@link Ext.form.Panel} class documentation.
 *
 * # Masking and Character Stripping
 *
 * Text fields can be configured with custom regular expressions to be applied to entered values before
 * validation: see {@link #maskRe} and {@link #stripCharsRe} for details.
 *
 * # Example usage
 *
 *     @example
 *     Ext.create(&#39;Ext.form.Panel&#39;, {
 *         title: &#39;Contact Info&#39;,
 *         width: 300,
 *         bodyPadding: 10,
 *         renderTo: Ext.getBody(),
 *         items: [{
 *             xtype: &#39;textfield&#39;,
 *             name: &#39;name&#39;,
 *             fieldLabel: &#39;Name&#39;,
 *             allowBlank: false  // requires a non-empty value
 *         }, {
 *             xtype: &#39;textfield&#39;,
 *             name: &#39;email&#39;,
 *             fieldLabel: &#39;Email Address&#39;,
 *             vtype: &#39;email&#39;  // requires value to be a valid email address format
 *         }]
 *     });
 */
Ext.define(&#39;Ext.form.field.Text&#39;, {
    extend:&#39;Ext.form.field.Base&#39;,
    alias: &#39;widget.textfield&#39;,
    requires: [&#39;Ext.form.field.VTypes&#39;, &#39;Ext.layout.component.field.Text&#39;],
    alternateClassName: [&#39;Ext.form.TextField&#39;, &#39;Ext.form.Text&#39;],

<span id='Ext-form-field-Text-cfg-vtypeText'>    /**
</span>     * @cfg {String} vtypeText
     * A custom error message to display in place of the default message provided for the **`{@link #vtype}`** currently
     * set for this field. **Note**: only applies if **`{@link #vtype}`** is set, else ignored.
     */

<span id='Ext-form-field-Text-cfg-stripCharsRe'>    /**
</span>     * @cfg {RegExp} stripCharsRe
     * A JavaScript RegExp object used to strip unwanted content from the value
     * during input. If `stripCharsRe` is specified,
     * every *character sequence* matching `stripCharsRe` will be removed.
     */

<span id='Ext-form-field-Text-cfg-size'>    /**
</span>     * @cfg {Number} size
     * An initial value for the &#39;size&#39; attribute on the text input element. This is only used if the field has no
     * configured {@link #width} and is not given a width by its container&#39;s layout. Defaults to 20.
     */
    size: 20,

<span id='Ext-form-field-Text-cfg-grow'>    /**
</span>     * @cfg {Boolean} [grow=false]
     * true if this field should automatically grow and shrink to its content
     */

<span id='Ext-form-field-Text-cfg-growMin'>    /**
</span>     * @cfg {Number} growMin
     * The minimum width to allow when `{@link #grow} = true`
     */
    growMin : 30,

<span id='Ext-form-field-Text-cfg-growMax'>    /**
</span>     * @cfg {Number} growMax
     * The maximum width to allow when `{@link #grow} = true`
     */
    growMax : 800,

    //&lt;locale&gt;
<span id='Ext-form-field-Text-cfg-growAppend'>    /**
</span>     * @cfg {String} growAppend
     * A string that will be appended to the field&#39;s current value for the purposes of calculating the target field
     * size. Only used when the {@link #grow} config is true. Defaults to a single capital &quot;W&quot; (the widest character in
     * common fonts) to leave enough space for the next typed character and avoid the field value shifting before the
     * width is adjusted.
     */
    growAppend: &#39;W&#39;,
    //&lt;/locale&gt;

<span id='Ext-form-field-Text-cfg-vtype'>    /**
</span>     * @cfg {String} vtype
     * A validation type name as defined in {@link Ext.form.field.VTypes}
     */

<span id='Ext-form-field-Text-cfg-maskRe'>    /**
</span>     * @cfg {RegExp} maskRe An input mask regular expression that will be used to filter keystrokes (character being
     * typed) that do not match.
     * Note: It does not filter characters already in the input.
     */

<span id='Ext-form-field-Text-cfg-disableKeyFilter'>    /**
</span>     * @cfg {Boolean} [disableKeyFilter=false]
     * Specify true to disable input keystroke filtering
     */

<span id='Ext-form-field-Text-cfg-allowBlank'>    /**
</span>     * @cfg {Boolean} [allowBlank=true]
     * Specify false to validate that the value&#39;s length must be &gt; 0. If `true`, then a blank value is **always** taken to be valid regardless of any {@link #vtype}
     * validation that may be applied.
     *
     * If {@link #vtype} validation must still be applied to blank values, configure {@link #validateBlank} as `true`;
     */
    allowBlank : true,

<span id='Ext-form-field-Text-cfg-validateBlank'>    /**
</span>     * @cfg {Boolean} [validateBlank=false]
     * Specify as `true` to modify the behaviour of {@link #allowBlank} so that blank values are not passed as valid, but are subject to any configure {@link #vtype} validation.
     */
    validateBlank: false,

<span id='Ext-form-field-Text-cfg-allowOnlyWhitespace'>    /**
</span>     * @cfg {Boolean} allowOnlyWhitespace
     * Specify false to automatically trim the value before validating
     * the whether the value is blank. Setting this to false automatically
     * sets {@link #allowBlank} to false.
     */
    allowOnlyWhitespace: true,

<span id='Ext-form-field-Text-cfg-minLength'>    /**
</span>     * @cfg {Number} minLength
     * Minimum input field length required
     */
    minLength : 0,

<span id='Ext-form-field-Text-cfg-maxLength'>    /**
</span>     * @cfg {Number} maxLength
     * Maximum input field length allowed by validation. This behavior is intended to
     * provide instant feedback to the user by improving usability to allow pasting and editing or overtyping and back
     * tracking. To restrict the maximum number of characters that can be entered into the field use the
     * **{@link Ext.form.field.Text#enforceMaxLength enforceMaxLength}** option.
     *
     * Defaults to Number.MAX_VALUE.
     */
    maxLength : Number.MAX_VALUE,

<span id='Ext-form-field-Text-cfg-enforceMaxLength'>    /**
</span>     * @cfg {Boolean} enforceMaxLength
     * True to set the maxLength property on the underlying input field. Defaults to false
     */

    //&lt;locale&gt;
<span id='Ext-form-field-Text-cfg-minLengthText'>    /**
</span>     * @cfg {String} minLengthText
     * Error text to display if the **{@link #minLength minimum length}** validation fails.
     */
    minLengthText : &#39;The minimum length for this field is {0}&#39;,
    //&lt;/locale&gt;

    //&lt;locale&gt;
<span id='Ext-form-field-Text-cfg-maxLengthText'>    /**
</span>     * @cfg {String} maxLengthText
     * Error text to display if the **{@link #maxLength maximum length}** validation fails
     */
    maxLengthText : &#39;The maximum length for this field is {0}&#39;,
    //&lt;/locale&gt;

<span id='Ext-form-field-Text-cfg-selectOnFocus'>    /**
</span>     * @cfg {Boolean} [selectOnFocus=false]
     * true to automatically select any existing field text when the field receives input focus
     */

    //&lt;locale&gt;
<span id='Ext-form-field-Text-cfg-blankText'>    /**
</span>     * @cfg {String} blankText
     * The error text to display if the **{@link #allowBlank}** validation fails
     */
    blankText : &#39;This field is required&#39;,
    //&lt;/locale&gt;

<span id='Ext-form-field-Text-cfg-validator'>    /**
</span>     * @cfg {Function} validator
     * A custom validation function to be called during field validation ({@link #getErrors}).
     * If specified, this function will be called first, allowing the developer to override the default validation
     * process.
     *
     * This function will be passed the following parameters:
     *
     * @cfg {Object} validator.value The current field value
     * @cfg {Boolean/String} validator.return
     *
     * - True if the value is valid
     * - An error message if the value is invalid
     */

<span id='Ext-form-field-Text-cfg-regex'>    /**
</span>     * @cfg {RegExp} regex
     * A JavaScript RegExp object to be tested against the field value during validation.
     * If the test fails, the field will be marked invalid using
     * either **{@link #regexText}** or **{@link #invalidText}**.
     */

<span id='Ext-form-field-Text-cfg-regexText'>    /**
</span>     * @cfg {String} regexText
     * The error text to display if **{@link #regex}** is used and the test fails during validation
     */
    regexText : &#39;&#39;,

<span id='Ext-form-field-Text-cfg-emptyText'>    /**
</span>     * @cfg {String} emptyText
     * The default text to place into an empty field.
     *
     * Note that normally this value will be submitted to the server if this field is enabled; to prevent this you can
     * set the {@link Ext.form.action.Action#submitEmptyText submitEmptyText} option of {@link Ext.form.Basic#submit} to
     * false.
     *
     * Also note that if you use {@link #inputType inputType}:&#39;file&#39;, {@link #emptyText} is not supported and should be
     * avoided.
     *
     * Note that for browsers that support it, setting this property will use the HTML 5 placeholder attribute, and for
     * older browsers that don&#39;t support the HTML 5 placeholder attribute the value will be placed directly into the input
     * element itself as the raw value. This means that older browsers will obfuscate the {@link #emptyText} value for
     * password input fields.
     */

<span id='Ext-form-field-Text-cfg-emptyCls'>    /**
</span>     * @cfg {String} [emptyCls=&#39;x-form-empty-field&#39;]
     * The CSS class to apply to an empty field to style the **{@link #emptyText}**.
     * This class is automatically added and removed as needed depending on the current field value.
     */
    emptyCls : Ext.baseCSSPrefix + &#39;form-empty-field&#39;,

<span id='Ext-form-field-Text-cfg-requiredCls'>    /**
</span>     * @cfg {String} [requiredCls=&#39;x-form-required-field&#39;]
     * The CSS class to apply to a required field, i.e. a field where **{@link #allowBlank}** is false.
     */
    requiredCls : Ext.baseCSSPrefix + &#39;form-required-field&#39;,

<span id='Ext-form-field-Text-cfg-enableKeyEvents'>    /**
</span>     * @cfg {Boolean} [enableKeyEvents=false]
     * true to enable the proxying of key events for the HTML input field
     */

    componentLayout: &#39;textfield&#39;,

<span id='Ext-form-field-Text-property-valueContainsPlaceholder'>    // private
</span>    valueContainsPlaceholder : false,


<span id='Ext-form-field-Text-method-initComponent'>    initComponent: function () {
</span>        var me = this;
        
        if (me.allowOnlyWhitespace === false) {
            me.allowBlank = false;
        }

        me.callParent();

        me.addEvents(
<span id='Ext-form-field-Text-event-autosize'>            /**
</span>             * @event autosize
             * Fires when the **{@link #autoSize}** function is triggered and the field is resized according to the
             * {@link #grow}/{@link #growMin}/{@link #growMax} configs as a result. This event provides a hook for the
             * developer to apply additional logic at runtime to resize the field if needed.
             * @param {Ext.form.field.Text} this This text field
             * @param {Number} width The new field width
             */
            &#39;autosize&#39;,

<span id='Ext-form-field-Text-event-keydown'>            /**
</span>             * @event keydown
             * Keydown input field event. This event only fires if **{@link #enableKeyEvents}** is set to true.
             * @param {Ext.form.field.Text} this This text field
             * @param {Ext.EventObject} e
             */
            &#39;keydown&#39;,
<span id='Ext-form-field-Text-event-keyup'>            /**
</span>             * @event keyup
             * Keyup input field event. This event only fires if **{@link #enableKeyEvents}** is set to true.
             * @param {Ext.form.field.Text} this This text field
             * @param {Ext.EventObject} e
             */
            &#39;keyup&#39;,
<span id='Ext-form-field-Text-event-keypress'>            /**
</span>             * @event keypress
             * Keypress input field event. This event only fires if **{@link #enableKeyEvents}** is set to true.
             * @param {Ext.form.field.Text} this This text field
             * @param {Ext.EventObject} e
             */
            &#39;keypress&#39;
        );
        me.addStateEvents(&#39;change&#39;);
        me.setGrowSizePolicy();
    },

<span id='Ext-form-field-Text-method-setGrowSizePolicy'>    // private
</span>    setGrowSizePolicy: function(){
        if (this.grow) {
            this.shrinkWrap |= 1; // width must shrinkWrap
        }    
    },

<span id='Ext-form-field-Text-method-initEvents'>    // private
</span>    initEvents : function(){
        var me = this,
            el = me.inputEl;

        me.callParent();
        if(me.selectOnFocus || me.emptyText){
            me.mon(el, &#39;mousedown&#39;, me.onMouseDown, me);
        }
        if(me.maskRe || (me.vtype &amp;&amp; me.disableKeyFilter !== true &amp;&amp; (me.maskRe = Ext.form.field.VTypes[me.vtype+&#39;Mask&#39;]))){
            me.mon(el, &#39;keypress&#39;, me.filterKeys, me);
        }

        if (me.enableKeyEvents) {
            me.mon(el, {
                scope: me,
                keyup: me.onKeyUp,
                keydown: me.onKeyDown,
                keypress: me.onKeyPress
            });
        }
    },

<span id='Ext-form-field-Text-method-isEqual'>    /**
</span>     * @private
     * Override. Treat undefined and null values as equal to an empty string value.
     */
    isEqual: function(value1, value2) {
        return this.isEqualAsString(value1, value2);
    },

<span id='Ext-form-field-Text-method-onChange'>    /**
</span>     * @private
     * If grow=true, invoke the autoSize method when the field&#39;s value is changed.
     */
    onChange: function(newVal, oldVal) {
        this.callParent(arguments);
        this.autoSize();
    },

<span id='Ext-form-field-Text-method-getSubTplData'>    getSubTplData: function() {
</span>        var me = this,
            value = me.getRawValue(),
            isEmpty = me.emptyText &amp;&amp; value.length &lt; 1,
            maxLength = me.maxLength,
            placeholder;
            
        // We can&#39;t just dump the value here, since MAX_VALUE ends up
        // being something like 1.xxxxe+300, which gets interpreted as 1
        // in the markup
        if (me.enforceMaxLength) {
            if (maxLength === Number.MAX_VALUE) {
                maxLength = undefined;
            }
        } else {
            maxLength = undefined;
        }

        if (isEmpty) {
            if (Ext.supports.Placeholder) {
                placeholder = me.emptyText;
            } else {
                value = me.emptyText;
                me.valueContainsPlaceholder = true;
            }
        }

        return Ext.apply(me.callParent(), {
            maxLength   : maxLength,
            readOnly    : me.readOnly,
            placeholder : placeholder,
            value       : value,
            fieldCls    : me.fieldCls + ((isEmpty &amp;&amp; (placeholder || value)) ? &#39; &#39; + me.emptyCls : &#39;&#39;) + (me.allowBlank ? &#39;&#39; :  &#39; &#39; + me.requiredCls)
        });
    },

<span id='Ext-form-field-Text-method-afterRender'>    afterRender: function(){
</span>        this.autoSize();
        this.callParent();
    },

<span id='Ext-form-field-Text-method-onMouseDown'>    onMouseDown: function(e){
</span>        var me = this;
        if(!me.hasFocus){
            me.mon(me.inputEl, &#39;mouseup&#39;, Ext.emptyFn, me, { single: true, preventDefault: true });
        }
    },

<span id='Ext-form-field-Text-method-processRawValue'>    /**
</span>     * Performs any necessary manipulation of a raw String value to prepare it for conversion and/or
     * {@link #validate validation}. For text fields this applies the configured {@link #stripCharsRe}
     * to the raw value.
     * @param {String} value The unprocessed string value
     * @return {String} The processed string value
     */
    processRawValue: function(value) {
        var me = this,
            stripRe = me.stripCharsRe,
            newValue;

        if (stripRe) {
            newValue = value.replace(stripRe, &#39;&#39;);
            if (newValue !== value) {
                me.setRawValue(newValue);
                value = newValue;
            }
        }
        return value;
    },

<span id='Ext-form-field-Text-method-onDisable'>    //private
</span>    onDisable: function(){
        this.callParent();
        if (Ext.isIE) {
            this.inputEl.dom.unselectable = &#39;on&#39;;
        }
    },

<span id='Ext-form-field-Text-method-onEnable'>    //private
</span>    onEnable: function(){
        this.callParent();
        if (Ext.isIE) {
            this.inputEl.dom.unselectable = &#39;&#39;;
        }
    },

<span id='Ext-form-field-Text-method-onKeyDown'>    onKeyDown: function(e) {
</span>        this.fireEvent(&#39;keydown&#39;, this, e);
    },

<span id='Ext-form-field-Text-method-onKeyUp'>    onKeyUp: function(e) {
</span>        this.fireEvent(&#39;keyup&#39;, this, e);
    },

<span id='Ext-form-field-Text-method-onKeyPress'>    onKeyPress: function(e) {
</span>        this.fireEvent(&#39;keypress&#39;, this, e);
    },

<span id='Ext-form-field-Text-method-reset'>    /**
</span>     * Resets the current field value to the originally-loaded value and clears any validation messages.
     * Also adds **{@link #emptyText}** and **{@link #emptyCls}** if the original value was blank.
     */
    reset : function(){
        this.callParent();
        this.applyEmptyText();
    },

<span id='Ext-form-field-Text-method-applyEmptyText'>    applyEmptyText : function(){
</span>        var me = this,
            emptyText = me.emptyText,
            isEmpty;

        if (me.rendered &amp;&amp; emptyText) {
            isEmpty = me.getRawValue().length &lt; 1 &amp;&amp; !me.hasFocus;

            if (Ext.supports.Placeholder) {
                me.inputEl.dom.placeholder = emptyText;
            } else if (isEmpty) {
                me.setRawValue(emptyText);
                me.valueContainsPlaceholder = true;
            }

            //all browsers need this because of a styling issue with chrome + placeholders.
            //the text isnt vertically aligned when empty (and using the placeholder)
            if (isEmpty) {
                me.inputEl.addCls(me.emptyCls);
            }

            me.autoSize();
        }
    },
    
<span id='Ext-form-field-Text-method-afterFirstLayout'>    afterFirstLayout: function() {
</span>        this.callParent();
        if (Ext.isIE &amp;&amp; this.disabled) {
            var el = this.inputEl;
            if (el) {
                el.dom.unselectable = &#39;on&#39;;
            }
        }
    },
    
<span id='Ext-form-field-Text-method-beforeFocus'>    // private
</span>    beforeFocus : function(){
        var me = this,
            inputEl = me.inputEl,
            emptyText = me.emptyText,
            isEmpty;

        me.callParent(arguments);
        if ((emptyText &amp;&amp; !Ext.supports.Placeholder) &amp;&amp; (inputEl.dom.value === me.emptyText &amp;&amp; me.valueContainsPlaceholder)) {
            me.setRawValue(&#39;&#39;);
            isEmpty = true;
            inputEl.removeCls(me.emptyCls);
            me.valueContainsPlaceholder = false;
        } else if (Ext.supports.Placeholder) {
            me.inputEl.removeCls(me.emptyCls);
        }
        if (me.selectOnFocus || isEmpty) {
            // see: http://code.google.com/p/chromium/issues/detail?id=4505
            if (Ext.isWebKit) {
                if (!me.inputFocusTask) {
                    me.inputFocusTask = new Ext.util.DelayedTask(me.focusInput, me);
                }
                me.inputFocusTask.delay(1);
            } else {
                inputEl.dom.select();
            }
        }
    },
    
<span id='Ext-form-field-Text-method-focusInput'>    focusInput: function(){
</span>        var input = this.inputEl;
        if (input) {
            input = input.dom;
            if (input) {
                input.select();
            }
        }    
    },

<span id='Ext-form-field-Text-method-onFocus'>    onFocus: function() {
</span>        var me = this;
        me.callParent(arguments);
        if (me.emptyText) {
            me.autoSize();
        }
    },

<span id='Ext-form-field-Text-method-postBlur'>    // private
</span>    postBlur : function(){
        this.callParent(arguments);
        this.applyEmptyText();
    },

<span id='Ext-form-field-Text-method-filterKeys'>    // private
</span>    filterKeys : function(e){
        /*
         * On European keyboards, the right alt key, Alt Gr, is used to type certain special characters.
         * JS detects a keypress of this as ctrlKey &amp; altKey. As such, we check that alt isn&#39;t pressed
         * so we can still process these special characters.
         */
        if (e.ctrlKey &amp;&amp; !e.altKey) {
            return;
        }
        var key = e.getKey(),
            charCode = String.fromCharCode(e.getCharCode());

        if((Ext.isGecko || Ext.isOpera) &amp;&amp; (e.isNavKeyPress() || key === e.BACKSPACE || (key === e.DELETE &amp;&amp; e.button === -1))){
            return;
        }

        if((!Ext.isGecko &amp;&amp; !Ext.isOpera) &amp;&amp; e.isSpecialKey() &amp;&amp; !charCode){
            return;
        }
        if(!this.maskRe.test(charCode)){
            e.stopEvent();
        }
    },

<span id='Ext-form-field-Text-method-getState'>    getState: function() {
</span>        return this.addPropertyToState(this.callParent(), &#39;value&#39;);
    },

<span id='Ext-form-field-Text-method-applyState'>    applyState: function(state) {
</span>        this.callParent(arguments);
        if(state.hasOwnProperty(&#39;value&#39;)) {
            this.setValue(state.value);
        }
    },

<span id='Ext-form-field-Text-method-getRawValue'>    /**
</span>     * Returns the raw String value of the field, without performing any normalization, conversion, or validation. Gets
     * the current value of the input element if the field has been rendered, ignoring the value if it is the
     * {@link #emptyText}. To get a normalized and converted value see {@link #getValue}.
     * @return {String} The raw String value of the field
     */
    getRawValue: function() {
        var me = this,
            v = me.callParent();
        if (v === me.emptyText &amp;&amp; me.valueContainsPlaceholder) {
            v = &#39;&#39;;
        }
        return v;
    },

<span id='Ext-form-field-Text-method-setValue'>    /**
</span>     * Sets a data value into the field and runs the change detection and validation. Also applies any configured
     * {@link #emptyText} for text fields. To set the value directly without these inspections see {@link #setRawValue}.
     * @param {Object} value The value to set
     * @return {Ext.form.field.Text} this
     */
    setValue: function(value) {
        var me = this,
            inputEl = me.inputEl;

        if (inputEl &amp;&amp; me.emptyText &amp;&amp; !Ext.isEmpty(value)) {
            inputEl.removeCls(me.emptyCls);
            me.valueContainsPlaceholder = false;
        }

        me.callParent(arguments);

        me.applyEmptyText();
        return me;
    },

<span id='Ext-form-field-Text-method-getErrors'>    /**
</span>     * Validates a value according to the field&#39;s validation rules and returns an array of errors
     * for any failing validations. Validation rules are processed in the following order:
     *
     * 1. **Field specific validator**
     *
     *     A validator offers a way to customize and reuse a validation specification.
     *     If a field is configured with a `{@link #validator}`
     *     function, it will be passed the current field value.  The `{@link #validator}`
     *     function is expected to return either:
     *
     *     - Boolean `true`  if the value is valid (validation continues).
     *     - a String to represent the invalid message if invalid (validation halts).
     *
     * 2. **Basic Validation**
     *
     *     If the `{@link #validator}` has not halted validation,
     *     basic validation proceeds as follows:
     *
     *     - `{@link #allowBlank}` : (Invalid message = `{@link #blankText}`)
     *
     *         Depending on the configuration of `{@link #allowBlank}`, a
     *         blank field will cause validation to halt at this step and return
     *         Boolean true or false accordingly.
     *
     *     - `{@link #minLength}` : (Invalid message = `{@link #minLengthText}`)
     *
     *         If the passed value does not satisfy the `{@link #minLength}`
     *         specified, validation halts.
     *
     *     -  `{@link #maxLength}` : (Invalid message = `{@link #maxLengthText}`)
     *
     *         If the passed value does not satisfy the `{@link #maxLength}`
     *         specified, validation halts.
     *
     * 3. **Preconfigured Validation Types (VTypes)**
     *
     *     If none of the prior validation steps halts validation, a field
     *     configured with a `{@link #vtype}` will utilize the
     *     corresponding {@link Ext.form.field.VTypes VTypes} validation function.
     *     If invalid, either the field&#39;s `{@link #vtypeText}` or
     *     the VTypes vtype Text property will be used for the invalid message.
     *     Keystrokes on the field will be filtered according to the VTypes
     *     vtype Mask property.
     *
     * 4. **Field specific regex test**
     *
     *     If none of the prior validation steps halts validation, a field&#39;s
     *     configured `{@link #regex}` test will be processed.
     *     The invalid message for this test is configured with `{@link #regexText}`
     *
     * @param {Object} value The value to validate. The processed raw value will be used if nothing is passed.
     * @return {String[]} Array of any validation errors
     */
    getErrors: function(value) {
        var me = this,
            errors = me.callParent(arguments),
            validator = me.validator,
            vtype = me.vtype,
            vtypes = Ext.form.field.VTypes,
            regex = me.regex,
            format = Ext.String.format,
            msg, trimmed, isBlank;

        value = value || me.processRawValue(me.getRawValue());

        if (Ext.isFunction(validator)) {
            msg = validator.call(me, value);
            if (msg !== true) {
                errors.push(msg);
            }
        }
        
        trimmed = me.allowOnlyWhitespace ? value : Ext.String.trim(value);

        if (trimmed.length &lt; 1 || (value === me.emptyText &amp;&amp; me.valueContainsPlaceholder)) {
            if (!me.allowBlank) {
                errors.push(me.blankText);
            }
            // If we are not configured to validate blank values, there cannot be any additional errors
            if (!me.validateBlank) {
                return errors;
            }
            isBlank = true;
        }

        // If a blank value has been allowed through, then exempt it dfrom the minLength check.
        // It must be allowed to hit the vtype validation.
        if (!isBlank &amp;&amp; value.length &lt; me.minLength) {
            errors.push(format(me.minLengthText, me.minLength));
        }

        if (value.length &gt; me.maxLength) {
            errors.push(format(me.maxLengthText, me.maxLength));
        }

        if (vtype) {
            if (!vtypes[vtype](value, me)) {
                errors.push(me.vtypeText || vtypes[vtype +&#39;Text&#39;]);
            }
        }

        if (regex &amp;&amp; !regex.test(value)) {
            errors.push(me.regexText || me.invalidText);
        }

        return errors;
    },

<span id='Ext-form-field-Text-method-selectText'>    /**
</span>     * Selects text in this field
     * @param {Number} [start=0] The index where the selection should start
     * @param {Number} [end] The index where the selection should end (defaults to the text length)
     */
    selectText : function(start, end){
        var me = this,
            v = me.getRawValue(),
            doFocus = true,
            el = me.inputEl.dom,
            undef,
            range;

        if (v.length &gt; 0) {
            start = start === undef ? 0 : start;
            end = end === undef ? v.length : end;
            if (el.setSelectionRange) {
                el.setSelectionRange(start, end);
            }
            else if(el.createTextRange) {
                range = el.createTextRange();
                range.moveStart(&#39;character&#39;, start);
                range.moveEnd(&#39;character&#39;, end - v.length);
                range.select();
            }
            doFocus = Ext.isGecko || Ext.isOpera;
        }
        if (doFocus) {
            me.focus();
        }
    },

<span id='Ext-form-field-Text-method-autoSize'>    /**
</span>     * Automatically grows the field to accomodate the width of the text up to the maximum field width allowed. This
     * only takes effect if {@link #grow} = true, and fires the {@link #autosize} event if the width changes.
     */
    autoSize: function() {
        var me = this;
        if (me.grow &amp;&amp; me.rendered) {
            me.autoSizing = true;
            me.updateLayout();
        }
    },

<span id='Ext-form-field-Text-method-afterComponentLayout'>    afterComponentLayout: function() {
</span>        var me = this,
            width;

        me.callParent(arguments);
        if (me.autoSizing) {
            width = me.inputEl.getWidth();
            if (width !== me.lastInputWidth) {
                me.fireEvent(&#39;autosize&#39;, me, width);
                me.lastInputWidth = width;
                delete me.autoSizing;
            }
        }
    },
    
<span id='Ext-form-field-Text-method-onDestroy'>    onDestroy: function(){
</span>        var me = this;
        me.callParent();
        
        if (me.inputFocusTask) {
            me.inputFocusTask.cancel();
            me.inputFocusTask = null;
        }
    }
});
</pre>
</body>
</html>

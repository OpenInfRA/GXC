<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='GXC-panel-Edit'>/**
</span> * An Editing/Attributes panel that can be used with WMS/WFS layers.
 */
Ext.define(&#39;GXC.panel.Edit&#39;, {
    extend: &#39;Ext.window.Window&#39;,
    requires: [
        &#39;GeoExt.Action&#39;,
        &#39;Ext.grid.column.Number&#39;,
        &#39;GeoExt.data.WmsDescribeLayerStore&#39;,
        &#39;GeoExt.data.FeatureStore&#39;,
        &#39;GeoExt.selection.FeatureModel&#39;,
        &#39;GeoExt.data.proxy.Protocol&#39;,
        &#39;Ext.grid.plugin.RowEditing&#39;
    ],

    alias: &#39;widget.gxc_window_edit&#39;,

<span id='GXC-panel-Edit-property-inject'>    inject: [
</span>        &#39;notificationService&#39;,
        &#39;mapService&#39;
    ],

<span id='GXC-panel-Edit-property-sourceLayer'>    /**
</span>     * The layer that the editing layer is derieved from.
     * If the source layer is a WFS layer, it may be used directly.
     * @type {OpenLayers.Layer}
     */
    sourceLayer: null,

<span id='GXC-panel-Edit-property-editingLayer'>    /**
</span>     * The editing layer which must suppoert WFST.
     * @type {OpenLayers.Layer.Vector}
     */
    editingLayer: null,

<span id='GXC-panel-Edit-property-selectControl'>    /**
</span>     * A control that will be used to select the feature to edit.
     * @type {OpenLayers.Control.SelectFeature}
     */
    selectControl: null,

<span id='GXC-panel-Edit-property-modifyControl'>    /**
</span>     * A modify control that is used to modify the feature.
     * @type {OpenLayers.Control.ModifyFeature}
     */
    modifyControl: null,

<span id='GXC-panel-Edit-cfg-layout'>    layout: &#39;fit&#39;,
</span>
<span id='GXC-panel-Edit-cfg-autoShow'>    autoShow: true,
</span>
<span id='GXC-panel-Edit-property-txtError'>    txtError: &#39;Tansaction error&#39;,
</span>
<span id='GXC-panel-Edit-method-initComponent'>    initComponent: function() {
</span>        var that = this,
            map = this.mapService.getMap(),
            featureType = this.featureType,
            attributeStore = this.attributeStore,
            featureTypeAttrs = attributeStore.model.featureTypeAttrs,
            fields = [],
            columns = [],
            geometryName, geometryType,
            geomRegex = /gml:(Multi)?(Point|Line|Polygon|Surface|Geometry).*/,
            types = {
                // mapping of xml schema data types to Ext JS data types
                &#39;xsd:int&#39;: &#39;int&#39;,
                &#39;xsd:short&#39;: &#39;int&#39;,
                &#39;xsd:long&#39;: &#39;int&#39;,
                &#39;xsd:string&#39;: &#39;string&#39;,
                &#39;xsd:dateTime&#39;: &#39;string&#39;,
                &#39;xsd:double&#39;: &#39;float&#39;,
                &#39;xsd:decimal&#39;: &#39;float&#39;,
                // mapping of geometry types
                &#39;Line&#39;: &#39;Path&#39;,
                &#39;Surface&#39;: &#39;Polygon&#39;
            };

        // generate the grids columns and the underlying stores fields.
        attributeStore.each(function(rec) {
            var type = rec.get(&#39;type&#39;),
                name = rec.get(&#39;name&#39;),
                match = geomRegex.exec(type);

            if (match) {
                // we found the geometry column
                geometryName = name;
                // Geometry type for the sketch handler:
                // match[2] is &quot;Point&quot;, &quot;Line&quot;, &quot;Polygon&quot;, &quot;Surface&quot; or &quot;Geometry&quot;
                geometryType = types[match[2]] || match[2];
            } else {
                // we have an attribute column
                fields.push({
                    name: name,
                    type: types[type]
                });
                columns.push({
                    xtype: types[type] === &#39;string&#39; ?
                        &#39;gridcolumn&#39; :
                        &#39;numbercolumn&#39;,
                    flex: 1,
                    dataIndex: name,
                    header: name,
                    // textfield editor for strings, numberfield for others
                    editor: {
                        xtype: types[type] === &quot;string&quot; ?
                            &quot;textfield&quot; :
                            &quot;numberfield&quot;
                    },
                    renderer: function(value, metaData) {
                        metaData.tdAttr = &#39;data-qtip=&quot;&#39; + value + &#39;&quot;&#39;;
                        return value;
                    }
                });
            }
        });

        if (this.sourceLayer.CLASS_NAME === &#39;OpenLayers.Layer.Vector&#39; &amp;&amp;
                this.sourceLayer.protocol) {
            // if the layer is a WFS layer we just have to make sure it
            // has the appropiate strategies to work with
            this.editingLayer = this.sourceLayer;

            this.saveStrategy = Ext.Array.findBy(this.editingLayer.strategies,
                function(strategy) {
                if (strategy instanceof OpenLayers.Strategy.Save) {
                    return true;
                }
            }, this);

            if (!this.saveStrategy) {
                this.saveStrategy = new OpenLayers.Strategy.Save();
                this.saveStrategy.setLayer(this.editingLayer);
                this.editingLayer.strategies.push(this.saveStrategy);
            }
        } else {
            this.saveStrategy = new OpenLayers.Strategy.Save();

            this.editingLayer = new OpenLayers.Layer.Vector(&quot;gx_edit&quot;, {
                strategies: [
                    new OpenLayers.Strategy.Fixed(),
                    this.saveStrategy
                ],
                protocol: new OpenLayers.Protocol.WFS({
                    url: featureType.owsURL,
                    version: &quot;1.0.0&quot;,
                    srsName: map.getProjection(),
                    geometryName: geometryName,
                    featureType: featureTypeAttrs.typeName,
                    featurePrefix: featureTypeAttrs.targetPrefix,
                    featureNS: featureTypeAttrs.targetNamespace
                }),
                displayInLayerSwitcher: false
            });

            map.addLayer(this.editingLayer);
        }

        this.saveStrategy.events.on({
            success: this.onSaveStrategySuccess,
            fail: this.onSaveStrategyFail,
            scope: this
        });

        this.modifyControl = new OpenLayers.Control.ModifyFeature(this.editingLayer, {
            standalone: true
        });

        this.drawControl = new OpenLayers.Control.DrawFeature(this.editingLayer,
            OpenLayers.Handler[geometryType], {
                handlerOptions: {multi: true}
            }
        );

        map.addControls([this.modifyControl, this.drawControl]);

        this.featureStore = Ext.create(&#39;GeoExt.data.FeatureStore&#39;, {
            layer: this.editingLayer,
            fields: fields,
            autoLoad: this.editingLayer !== this.sourceLayer
        });

        this.editingLayer.events.on({
            featuremodified: function(e) {
                var record = this.featureStore.getByFeature(e.feature),
                    grid = this.query(&#39;grid&#39;)[0];

                if (record) {
                  record.setDirty();
                }

                if (grid) {
                  grid.getView().refresh();
                }
            },
            scope: this
        });

        this.items = [
            Ext.create(&#39;Ext.grid.Panel&#39;, {
                xtype: &#39;grid&#39;,
                plugins: [{
                    ptype: &#39;rowediting&#39;,
                    clicksToEdit: 2
                }],
                itemId: &#39;featuregrid&#39;,
                title: &#39;Feature Table&#39;,
                height: 300,
                selType: &#39;featuremodel&#39;,
                selModel: {
                    mode: &#39;SINGLE&#39;
                },
                store: this.featureStore,
                columns: columns,
                bbar: [{
                    text: &quot;Delete&quot;,
                    handler: function() {
                        var grid = this.up(&#39;grid&#39;),
                            sm = grid.getSelectionModel();

                        grid.getStore().featureFilter = new OpenLayers.Filter({
                            evaluate: function(feature) {
                                return feature.state !== OpenLayers.State.DELETE;
                            }
                        });

                        Ext.Array.each(sm.getSelection(), function(rec) {
                            var feature = rec.raw;
                            that.modifyControl.unselectFeature(feature);
                            that.editingLayer.removeFeatures([feature]);
                            if (feature.state !== OpenLayers.State.INSERT) {
                                feature.state = OpenLayers.State.DELETE;
                                that.editingLayer.addFeatures([feature]);
                            }
                        });
                    }
                },
                Ext.create(&#39;Ext.button.Button&#39;, Ext.create(&#39;GeoExt.Action&#39;, {
                    control: this.drawControl,
                    text: &#39;Create&#39;,
                    enableToggle: true
                })), {
                    text: &#39;Save&#39;,
                    handler: function() {
                        that.drawControl.deactivate();
                        that.modifyControl.deactivate();
                        this.saveStrategy.save();
                    },
                    scope: this
                }],
                listeners: {
                    beforedestroy: function(grid) {
                        var sm = grid.getSelectionModel();
                        sm.deselectAll();
                        sm.unbindLayer();
                        sm.destroy();
                    }
                }
            })
        ];

        this.editingLayer.events.on({
            featureselected: this.selectFeature,
            featureunselected: this.unselectFeature,
            scope: this
        });

        this.callParent(arguments);
    },

<span id='GXC-panel-Edit-method-onSaveStrategySuccess'>    /**
</span>     * Called when the save strategy of the editing layer succeeds.
     * Commits the changes on the client side to reflect server state.
     * WMS-Layers are redrawn to update map view.
     */
    onSaveStrategySuccess: function() {
        Ext.Array.each(this.featureStore.getModifiedRecords(), function(model) {
            model.commit();
        });

        if (this.sourceLayer.CLASS_NAME === &#39;OpenLayers.Layer.WMS&#39;) {
            this.sourceLayer.redraw(true);
        }
    },

<span id='GXC-panel-Edit-method-onSaveStrategyFail'>    /**
</span>     * Called when the save strategy of the editing layers fails.
     * Shows an error message that is retrieved from the server response.
     * @param  {String} e The Error
     */
    onSaveStrategyFail: function(e) {
        var responseDoc = e.response.priv.responseXML,
            messageNode = responseDoc.getElementsByTagName(&#39;Message&#39;)[0];

        if (messageNode) {
            this.notificationService.error(this.txtError, messageNode.innerHTML);
        } else {
            this.notificationService.error(this.txtError, &#39;An error occured&#39;);
        }
    },

<span id='GXC-panel-Edit-method-selectFeature'>    /**
</span>     * Called on feature selection of the editing layer.
     * Activated the modify control to allow interactive changes to the feature.
     * @param  {[type]} e The event
     */
    selectFeature: function(e) {
        this.modifyControl.selectFeature(e.feature);
        this.modifyControl.activate();
    },

<span id='GXC-panel-Edit-method-unselectFeature'>    /**
</span>     * Called on unselect on a feature.
     * Deactivates the modify control.
     *
     * @param  {[type]} e The event
     */
    unselectFeature: function(e) {
        this.modifyControl.unselectFeature(e.feature);
        this.modifyControl.deactivate();
    },

<span id='GXC-panel-Edit-method-onDestroy'>    /**
</span>     * Unbinds event handlers on destroy of the panel.
     */
    onDestroy: function() {
        var map = this.mapService.getMap();

        this.saveStrategy.events.un({
            success: this.onSaveStrategySuccess,
            scope: this
        });

         this.editingLayer.events.un({
            featureselected: this.selectFeature,
            featureunselected: this.unselectFeature,
            scope: this
        });

        this.featureStore.unbind();

        this.modifyControl.deactivate();
        this.drawControl.deactivate();

        this.modifyControl.destroy();
        this.drawControl.destroy();
        delete this.modifyControl;
        delete this.drawControl;

        // we keep the layer on the map if it wasn&#39;t provided by us.
        if (this.editingLayer !== this.sourceLayer) {
            map.removeLayer(this.editingLayer);
            this.editingLayer.destroy();
        } else {
            this.editingLayer.strategies[0].load();
        }

        delete this.saveStrategy;
        delete this.editingLayer;
        delete this.attributeStore;
        delete this.featureType;

        this.callParent(arguments);
    }
});
</pre>
</body>
</html>

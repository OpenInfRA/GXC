<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
This file is part of Ext JS 4.2

Copyright (c) 2011-2013 Sencha Inc

Contact:  http://www.sencha.com/contact

GNU General Public License Usage
This file may be used under the terms of the GNU General Public License version 3.0 as
published by the Free Software Foundation and appearing in the file LICENSE included in the
packaging of this file.

Please review the following information to ensure the GNU General Public License version 3.0
requirements will be met: http://www.gnu.org/copyleft/gpl.html.

If you are unsure which license is appropriate for your use, please contact the sales department
at http://www.sencha.com/contact.

Build date: 2013-05-16 14:36:50 (f9be68accb407158ba2b1be2c226a6ce1f649314)
*/
<span id='Ext-chart-Chart'>/**
</span> * Charts provide a flexible way to achieve a wide range of data visualization capablitities.
 * Each Chart gets its data directly from a {@link Ext.data.Store Store}, and automatically
 * updates its display whenever data in the Store changes. In addition, the look and feel
 * of a Chart can be customized using {@link Ext.chart.theme.Theme Theme}s.
 * 
 * ## Creating a Simple Chart
 * 
 * Every Chart has three key parts - a {@link Ext.data.Store Store} that contains the data,
 * an array of {@link Ext.chart.axis.Axis Axes} which define the boundaries of the Chart,
 * and one or more {@link Ext.chart.series.Series Series} to handle the visual rendering of the data points.
 * 
 * ### 1. Creating a Store
 * 
 * The first step is to create a {@link Ext.data.Model Model} that represents the type of
 * data that will be displayed in the Chart. For example the data for a chart that displays
 * a weather forecast could be represented as a series of &quot;WeatherPoint&quot; data points with
 * two fields - &quot;temperature&quot;, and &quot;date&quot;:
 * 
 *     Ext.define(&#39;WeatherPoint&#39;, {
 *         extend: &#39;Ext.data.Model&#39;,
 *         fields: [&#39;temperature&#39;, &#39;date&#39;]
 *     });
 * 
 * Next a {@link Ext.data.Store Store} must be created.  The store contains a collection of &quot;WeatherPoint&quot; Model instances.
 * The data could be loaded dynamically, but for sake of ease this example uses inline data:
 * 
 *     var store = Ext.create(&#39;Ext.data.Store&#39;, {
 *         model: &#39;WeatherPoint&#39;,
 *         data: [
 *             { temperature: 58, date: new Date(2011, 1, 1, 8) },
 *             { temperature: 63, date: new Date(2011, 1, 1, 9) },
 *             { temperature: 73, date: new Date(2011, 1, 1, 10) },
 *             { temperature: 78, date: new Date(2011, 1, 1, 11) },
 *             { temperature: 81, date: new Date(2011, 1, 1, 12) }
 *         ]
 *     });
 *    
 * For additional information on Models and Stores please refer to the [Data Guide](#/guide/data).
 * 
 * ### 2. Creating the Chart object
 * 
 * Now that a Store has been created it can be used in a Chart:
 * 
 *     Ext.create(&#39;Ext.chart.Chart&#39;, {
 *        renderTo: Ext.getBody(),
 *        width: 400,
 *        height: 300,
 *        store: store
 *     });
 *    
 * That&#39;s all it takes to create a Chart instance that is backed by a Store.
 * However, if the above code is run in a browser, a blank screen will be displayed.
 * This is because the two pieces that are responsible for the visual display,
 * the Chart&#39;s {@link #cfg-axes axes} and {@link #cfg-series series}, have not yet been defined.
 * 
 * ### 3. Configuring the Axes
 * 
 * {@link Ext.chart.axis.Axis Axes} are the lines that define the boundaries of the data points that a Chart can display.
 * This example uses one of the most common Axes configurations - a horizontal &quot;x&quot; axis, and a vertical &quot;y&quot; axis:
 * 
 *     Ext.create(&#39;Ext.chart.Chart&#39;, {
 *         ...
 *         axes: [
 *             {
 *                 title: &#39;Temperature&#39;,
 *                 type: &#39;Numeric&#39;,
 *                 position: &#39;left&#39;,
 *                 fields: [&#39;temperature&#39;],
 *                 minimum: 0,
 *                 maximum: 100
 *             },
 *             {
 *                 title: &#39;Time&#39;,
 *                 type: &#39;Time&#39;,
 *                 position: &#39;bottom&#39;,
 *                 fields: [&#39;date&#39;],
 *                 dateFormat: &#39;ga&#39;
 *             }
 *         ]
 *     });
 *    
 * The &quot;Temperature&quot; axis is a vertical {@link Ext.chart.axis.Numeric Numeric Axis} and is positioned on the left edge of the Chart.
 * It represents the bounds of the data contained in the &quot;WeatherPoint&quot; Model&#39;s &quot;temperature&quot; field that was
 * defined above. The minimum value for this axis is &quot;0&quot;, and the maximum is &quot;100&quot;.
 * 
 * The horizontal axis is a {@link Ext.chart.axis.Time Time Axis} and is positioned on the bottom edge of the Chart.
 * It represents the bounds of the data contained in the &quot;WeatherPoint&quot; Model&#39;s &quot;date&quot; field.
 * The {@link Ext.chart.axis.Time#cfg-dateFormat dateFormat}
 * configuration tells the Time Axis how to format it&#39;s labels.
 * 
 * Here&#39;s what the Chart looks like now that it has its Axes configured:
 * 
 * {@img Ext.chart.Chart/Ext.chart.Chart1.png Chart Axes}
 * 
 * ### 4. Configuring the Series
 * 
 * The final step in creating a simple Chart is to configure one or more {@link Ext.chart.series.Series Series}.
 * Series are responsible for the visual representation of the data points contained in the Store.
 * This example only has one Series:
 * 
 *     Ext.create(&#39;Ext.chart.Chart&#39;, {
 *         ...
 *         axes: [
 *             ...
 *         ],
 *         series: [
 *             {
 *                 type: &#39;line&#39;,
 *                 xField: &#39;date&#39;,
 *                 yField: &#39;temperature&#39;
 *             }
 *         ]
 *     });
 *     
 * This Series is a {@link Ext.chart.series.Line Line Series}, and it uses the &quot;date&quot; and &quot;temperature&quot; fields
 * from the &quot;WeatherPoint&quot; Models in the Store to plot its data points:
 * 
 * {@img Ext.chart.Chart/Ext.chart.Chart2.png Line Series}
 * 
 * See the [Line Charts Example](#!/example/charts/Charts.html) for a live demo.
 * 
 * ## Themes
 * 
 * The color scheme for a Chart can be easily changed using the {@link #cfg-theme theme} configuration option:
 * 
 *     Ext.create(&#39;Ext.chart.Chart&#39;, {
 *         ...
 *         theme: &#39;Green&#39;,
 *         ...
 *     });
 * 
 * {@img Ext.chart.Chart/Ext.chart.Chart3.png Green Theme}
 * 
 * For more information on Charts please refer to the [Charting Guide](#/guide/charting).
 */
Ext.define(&#39;Ext.chart.Chart&#39;, {
    extend: &#39;Ext.draw.Component&#39;,

    alias: &#39;widget.chart&#39;,
    
    mixins: {
        themeManager: &#39;Ext.chart.theme.Theme&#39;,
        mask: &#39;Ext.chart.Mask&#39;,
        navigation: &#39;Ext.chart.Navigation&#39;,
        bindable: &#39;Ext.util.Bindable&#39;,
        observable: &#39;Ext.util.Observable&#39;
    },

    uses: [
        &#39;Ext.chart.series.Series&#39;
    ],
    
    requires: [
        &#39;Ext.util.MixedCollection&#39;,
        &#39;Ext.data.StoreManager&#39;,
        &#39;Ext.chart.Legend&#39;,
        &#39;Ext.chart.theme.Base&#39;,
        &#39;Ext.chart.theme.Theme&#39;,
        &#39;Ext.util.DelayedTask&#39;
    ],

    /* End Definitions */

<span id='Ext-chart-Chart-cfg-viewBox'>    // @private
</span>    viewBox: false,

<span id='Ext-chart-Chart-cfg-theme'>    /**
</span>     * @cfg {String} theme
     * The name of the theme to be used. A theme defines the colors and other visual displays of tick marks
     * on axis, text, title text, line colors, marker colors and styles, etc. Possible theme values are &#39;Base&#39;, &#39;Green&#39;,
     * &#39;Sky&#39;, &#39;Red&#39;, &#39;Purple&#39;, &#39;Blue&#39;, &#39;Yellow&#39; and also six category themes &#39;Category1&#39; to &#39;Category6&#39;. Default value
     * is &#39;Base&#39;.
     */

<span id='Ext-chart-Chart-cfg-animate'>    /**
</span>     * @cfg {Boolean/Object} animate
     * True for the default animation (easing: &#39;ease&#39; and duration: 500) or a standard animation config
     * object to be used for default chart animations. Defaults to false.
     */
    animate: false,

<span id='Ext-chart-Chart-cfg-legend'>    /**
</span>     * @cfg {Boolean/Object} legend
     * True for the default legend display or a legend config object. Defaults to false.
     */
    legend: false,

<span id='Ext-chart-Chart-cfg-insetPadding'>    /**
</span>     * @cfg {Number} insetPadding
     * The amount of inset padding in pixels for the chart. Defaults to 10.
     */
    insetPadding: 10,

<span id='Ext-chart-Chart-cfg-background'>    /**
</span>     * @cfg {Object/Boolean} background
     * The chart background. This can be a gradient object, image, or color. Defaults to false for no
     * background. For example, if `background` were to be a color we could set the object as
     *
     *     background: {
     *         //color string
     *         fill: &#39;#ccc&#39;
     *     }
     *
     * You can specify an image by using:
     *
     *     background: {
     *         image: &#39;http://path.to.image/&#39;
     *     }
     *
     * Also you can specify a gradient by using the gradient object syntax:
     *
     *     background: {
     *         gradient: {
     *             id: &#39;gradientId&#39;,
     *             angle: 45,
     *             stops: {
     *                 0: {
     *                     color: &#39;#555&#39;
     *                 }
     *                 100: {
     *                     color: &#39;#ddd&#39;
     *                 }
     *             }
     *         }
     *     }
     */
    background: false,

<span id='Ext-chart-Chart-cfg-gradients'>    /**
</span>     * @cfg {Object[]} gradients
     * Define a set of gradients that can be used as `fill` property in sprites. The gradients array is an
     * array of objects with the following properties:
     *
     * - **id** - string - The unique name of the gradient.
     * - **angle** - number, optional - The angle of the gradient in degrees.
     * - **stops** - object - An object with numbers as keys (from 0 to 100) and style objects as values
     *
     * For example:
     *
     *     gradients: [{
     *         id: &#39;gradientId&#39;,
     *         angle: 45,
     *         stops: {
     *             0: {
     *                 color: &#39;#555&#39;
     *             },
     *             100: {
     *                 color: &#39;#ddd&#39;
     *             }
     *         }
     *     }, {
     *         id: &#39;gradientId2&#39;,
     *         angle: 0,
     *         stops: {
     *             0: {
     *                 color: &#39;#590&#39;
     *             },
     *             20: {
     *                 color: &#39;#599&#39;
     *             },
     *             100: {
     *                 color: &#39;#ddd&#39;
     *             }
     *         }
     *     }]
     *
     * Then the sprites can use `gradientId` and `gradientId2` by setting the fill attributes to those ids, for example:
     *
     *     sprite.setAttributes({
     *         fill: &#39;url(#gradientId)&#39;
     *     }, true);
     */

<span id='Ext-chart-Chart-cfg-store'>    /**
</span>     * @cfg {Ext.data.Store} store
     * The store that supplies data to this chart.
     */

<span id='Ext-chart-Chart-cfg-series'>    /**
</span>     * @cfg {Ext.chart.series.Series[]} series
     * Array of {@link Ext.chart.series.Series Series} instances or config objects.  For example:
     * 
     *     series: [{
     *         type: &#39;column&#39;,
     *         axis: &#39;left&#39;,
     *         listeners: {
     *             &#39;afterrender&#39;: function() {
     *                 console(&#39;afterrender&#39;);
     *             }
     *         },
     *         xField: &#39;category&#39;,
     *         yField: &#39;data1&#39;
     *     }]
     */

<span id='Ext-chart-Chart-cfg-axes'>    /**
</span>     * @cfg {Ext.chart.axis.Axis[]} axes
     * Array of {@link Ext.chart.axis.Axis Axis} instances or config objects.  For example:
     * 
     *     axes: [{
     *         type: &#39;Numeric&#39;,
     *         position: &#39;left&#39;,
     *         fields: [&#39;data1&#39;],
     *         title: &#39;Number of Hits&#39;,
     *         minimum: 0,
     *         //one minor tick between two major ticks
     *         minorTickSteps: 1
     *     }, {
     *         type: &#39;Category&#39;,
     *         position: &#39;bottom&#39;,
     *         fields: [&#39;name&#39;],
     *         title: &#39;Month of the Year&#39;
     *     }]
     */

    constructor: function(config) {
        var me = this,
            defaultAnim;

        config = Ext.apply({}, config);
        me.initTheme(config.theme || me.theme);
        if (me.gradients) {
            Ext.apply(config, { gradients: me.gradients });
        }
        if (me.background) {
            Ext.apply(config, { background: me.background });
        }
        if (config.animate) {
            defaultAnim = {
                easing: &#39;ease&#39;,
                duration: 500
            };
            if (Ext.isObject(config.animate)) {
                config.animate = Ext.applyIf(config.animate, defaultAnim);
            }
            else {
                config.animate = defaultAnim;
            }
        }

        me.mixins.observable.constructor.call(me, config);
        if (config.enableMask) {
            me.mixins.mask.constructor.call(me);
        }
        me.mixins.navigation.constructor.call(me);
        me.callParent([config]);
    },
    
<span id='Ext-chart-Chart-method-getChartStore'>    getChartStore: function(){
</span>        return this.substore || this.store;
    },

<span id='Ext-chart-Chart-method-initComponent'>    initComponent: function() {
</span>        var me = this,
            axes,
            series;
        me.callParent();
        me.addEvents(
            &#39;itemmousedown&#39;,
            &#39;itemmouseup&#39;,
            &#39;itemmouseover&#39;,
            &#39;itemmouseout&#39;,
            &#39;itemclick&#39;,
            &#39;itemdblclick&#39;,
            &#39;itemdragstart&#39;,
            &#39;itemdrag&#39;,
            &#39;itemdragend&#39;,
<span id='Ext-chart-Chart-event-beforerefresh'>            /**
</span>             * @event beforerefresh
             * Fires before a refresh to the chart data is called. If the beforerefresh handler returns false the
             * {@link #event-refresh} action will be cancelled.
             * @param {Ext.chart.Chart} this
             */
            &#39;beforerefresh&#39;,
<span id='Ext-chart-Chart-event-refresh'>            /**
</span>             * @event refresh
             * Fires after the chart data has been refreshed.
             * @param {Ext.chart.Chart} this
             */
            &#39;refresh&#39;
        );
        Ext.applyIf(me, {
            zoom: {
                width: 1,
                height: 1,
                x: 0,
                y: 0
            }
        });
        me.maxGutters = { left: 0, right: 0, bottom: 0, top: 0 };
        me.store = Ext.data.StoreManager.lookup(me.store);
        axes = me.axes;
        me.axes = new Ext.util.MixedCollection(false, function(a) { return a.position; });
        if (axes) {
            me.axes.addAll(axes);
        }
        series = me.series;
        me.series = new Ext.util.MixedCollection(false, function(a) { return a.seriesId || (a.seriesId = Ext.id(null, &#39;ext-chart-series-&#39;)); });
        if (series) {
            me.series.addAll(series);
        }
        if (me.legend !== false) {
            me.legend = new Ext.chart.Legend(Ext.applyIf({chart:me}, me.legend));
        }

        me.on({
            mousemove: me.onMouseMove,
            mouseleave: me.onMouseLeave,
            mousedown: me.onMouseDown,
            mouseup: me.onMouseUp,
            click: me.onClick,
            dblclick: me.onDblClick,
            scope: me
        });
    },

<span id='Ext-chart-Chart-method-afterComponentLayout'>    // @private overrides the component method to set the correct dimensions to the chart.
</span>    afterComponentLayout: function(width, height, oldWidth, oldHeight) {
        var me = this;
        if (Ext.isNumber(width) &amp;&amp; Ext.isNumber(height)) {
            if (width !== oldWidth || height !== oldHeight) {
                me.curWidth = width;
                me.curHeight = height;
                me.redraw(true);
                me.needsRedraw = false;
            } else if (me.needsRedraw) {
                me.redraw();
                me.needsRedraw = false;
            }
        }
        this.callParent(arguments);
    },

<span id='Ext-chart-Chart-method-redraw'>    /**
</span>     * Redraws the chart. If animations are set this will animate the chart too. 
     * @param {Boolean} resize (optional) flag which changes the default origin points of the chart for animations.
     */
    redraw: function(resize) {
        var me = this,
            seriesItems = me.series.items,
            seriesLen = seriesItems.length,
            axesItems = me.axes.items,
            axesLen = axesItems.length,
            themeIndex = 0,
            i, item,
            chartBBox = me.chartBBox = {
                x: 0,
                y: 0,
                height: me.curHeight,
                width: me.curWidth
            },
            legend = me.legend, 
            series;
            
        me.surface.setSize(chartBBox.width, chartBBox.height);
        // Instantiate Series and Axes
        for (i = 0; i &lt; seriesLen; i++) {
            item = seriesItems[i];
            if (!item.initialized) {
                series = me.initializeSeries(item, i, themeIndex);
            } else {
                series = item;
            }
            // Allow the series to react to a redraw, for example, a pie series
            // backed by a remote data set needs to build legend labels correctly
            series.onRedraw();
            // For things like stacked bar charts, a single series can consume
            // multiple colors from the index, so we compensate for it here
            if (Ext.isArray(item.yField)) {
                themeIndex += item.yField.length;
            } else {
                ++themeIndex;
            }
        }
        for (i = 0; i &lt; axesLen; i++) {
            item = axesItems[i];
            if (!item.initialized) {
                me.initializeAxis(item);
            }
        }
        //process all views (aggregated data etc) on stores
        //before rendering.
        for (i = 0; i &lt; axesLen; i++) {
            axesItems[i].processView();
        }
        for (i = 0; i &lt; axesLen; i++) {
            axesItems[i].drawAxis(true);
        }

        // Create legend if not already created
        if (legend !== false &amp;&amp; legend.visible) {
            if (legend.update || !legend.created) {
                legend.create();
            }
        }

        // Place axes properly, including influence from each other
        me.alignAxes();

        // Reposition legend based on new axis alignment
        if (legend !== false &amp;&amp; legend.visible) {
            legend.updatePosition();
        }

        // Find the max gutters
        me.getMaxGutters();

        // Draw axes and series
        me.resizing = !!resize;

        for (i = 0; i &lt; axesLen; i++) {
            axesItems[i].drawAxis();
        }
        for (i = 0; i &lt; seriesLen; i++) {
            me.drawCharts(seriesItems[i]);
        }
        me.resizing = false;
    },

<span id='Ext-chart-Chart-method-afterRender'>    // @private set the store after rendering the chart.
</span>    afterRender: function() {
        var me = this;
        
        me.callParent(arguments);

        if (me.categoryNames) {
            me.setCategoryNames(me.categoryNames);
        }

        me.bindStore(me.store, true);
        me.refresh();

        if (me.surface.engine === &#39;Vml&#39;) {
            me.on(&#39;added&#39;, me.onAddedVml, me);
            me.mon(me.hierarchyEventSource, &#39;added&#39;, me.onContainerAddedVml, me);
        }
    },

<span id='Ext-chart-Chart-method-onAddedVml'>    // When using a vml surface we need to redraw when this chart or one of its ancestors
</span>    // is moved to a new container after render, because moving the vml chart causes the
    // vml elements to go haywire, some displaing incorrectly or not displaying at all.
    // This appears to be caused by the component being moved to the detached body element
    // before being added to the new container.
    onAddedVml: function() {
        this.needsRedraw = true; // redraw after component layout
    },

<span id='Ext-chart-Chart-method-onContainerAddedVml'>    onContainerAddedVml: function(container) {
</span>        if (this.isDescendantOf(container)) {
            this.needsRedraw = true; // redraw after component layout
        }
    },

<span id='Ext-chart-Chart-method-getEventXY'>    // @private get x and y position of the mouse cursor.
</span>    getEventXY: function(e) {
        var me = this,
            box = this.surface.getRegion(),
            pageXY = e.getXY(),
            x = pageXY[0] - box.left,
            y = pageXY[1] - box.top;
        return [x, y];
    },
    
<span id='Ext-chart-Chart-method-onClick'>    onClick: function(e) {
</span>        this.handleClick(&#39;itemclick&#39;, e);
    },
    
<span id='Ext-chart-Chart-method-onDblClick'>    onDblClick: function(e) {
</span>        this.handleClick(&#39;itemdblclick&#39;, e);
    },

<span id='Ext-chart-Chart-method-handleClick'>    // @private wrap the mouse down position to delegate the event to the series.
</span>    handleClick: function(name, e) {
        var me = this,
            position = me.getEventXY(e),
            seriesItems = me.series.items,
            i, ln, series,
            item;

        // Ask each series if it has an item corresponding to (not necessarily exactly
        // on top of) the current mouse coords. Fire itemclick event.
        for (i = 0, ln = seriesItems.length; i &lt; ln; i++) {
            series = seriesItems[i];
            if (Ext.draw.Draw.withinBox(position[0], position[1], series.bbox)) {
                if (series.getItemForPoint) {
                    item = series.getItemForPoint(position[0], position[1]);
                    if (item) {
                        series.fireEvent(name, item);
                    }
                }
            }
        }
    },

<span id='Ext-chart-Chart-method-onMouseDown'>    // @private wrap the mouse down position to delegate the event to the series.
</span>    onMouseDown: function(e) {
        var me = this,
            position = me.getEventXY(e),
            seriesItems = me.series.items,
            i, ln, series,
            item;

        if (me.enableMask) {
            me.mixins.mask.onMouseDown.call(me, e);
        }
        // Ask each series if it has an item corresponding to (not necessarily exactly
        // on top of) the current mouse coords. Fire itemmousedown event.
        for (i = 0, ln = seriesItems.length; i &lt; ln; i++) {
            series = seriesItems[i];
            if (Ext.draw.Draw.withinBox(position[0], position[1], series.bbox)) {
                if (series.getItemForPoint) {
                    item = series.getItemForPoint(position[0], position[1]);
                    if (item) {
                        series.fireEvent(&#39;itemmousedown&#39;, item);
                    }
                }
            }
        }
    },

<span id='Ext-chart-Chart-method-onMouseUp'>    // @private wrap the mouse up event to delegate it to the series.
</span>    onMouseUp: function(e) {
        var me = this,
            position = me.getEventXY(e),
            seriesItems = me.series.items,
            i, ln, series,
            item;

        if (me.enableMask) {
            me.mixins.mask.onMouseUp.call(me, e);
        }
        // Ask each series if it has an item corresponding to (not necessarily exactly
        // on top of) the current mouse coords. Fire itemmouseup event.
        for (i = 0, ln = seriesItems.length; i &lt; ln; i++) {
            series = seriesItems[i];
            if (Ext.draw.Draw.withinBox(position[0], position[1], series.bbox)) {
                if (series.getItemForPoint) {
                    item = series.getItemForPoint(position[0], position[1]);
                    if (item) {
                        series.fireEvent(&#39;itemmouseup&#39;, item);
                    }
                }
            }
        }
    },

<span id='Ext-chart-Chart-method-onMouseMove'>    // @private wrap the mouse move event so it can be delegated to the series.
</span>    onMouseMove: function(e) {
        var me = this,
            position = me.getEventXY(e),
            seriesItems = me.series.items,
            i, ln, series,
            item, last, storeItem, storeField;

        
        if (me.enableMask) {
            me.mixins.mask.onMouseMove.call(me, e);
        }
        // Ask each series if it has an item corresponding to (not necessarily exactly
        // on top of) the current mouse coords. Fire itemmouseover/out events.
        for (i = 0, ln = seriesItems.length; i &lt; ln; i++) {
            series = seriesItems[i];
            if (Ext.draw.Draw.withinBox(position[0], position[1], series.bbox)) {
                if (series.getItemForPoint) {
                    item = series.getItemForPoint(position[0], position[1]);
                    last = series._lastItemForPoint;
                    storeItem = series._lastStoreItem;
                    storeField = series._lastStoreField;


                    if (item !== last || item &amp;&amp; (item.storeItem != storeItem || item.storeField != storeField)) {
                        if (last) {
                            series.fireEvent(&#39;itemmouseout&#39;, last);
                            delete series._lastItemForPoint;
                            delete series._lastStoreField;
                            delete series._lastStoreItem;
                        }
                        if (item) {
                            series.fireEvent(&#39;itemmouseover&#39;, item);
                            series._lastItemForPoint = item;
                            series._lastStoreItem = item.storeItem;
                            series._lastStoreField = item.storeField;
                        }
                    }
                }
            } else {
                last = series._lastItemForPoint;
                if (last) {
                    series.fireEvent(&#39;itemmouseout&#39;, last);
                    delete series._lastItemForPoint;
                    delete series._lastStoreField;
                    delete series._lastStoreItem;
                }
            }
        }
    },

<span id='Ext-chart-Chart-method-onMouseLeave'>    // @private handle mouse leave event.
</span>    onMouseLeave: function(e) {
        var me = this,
            seriesItems = me.series.items,
            i, ln, series;

        if (me.enableMask) {
            me.mixins.mask.onMouseLeave.call(me, e);
        }
        for (i = 0, ln = seriesItems.length; i &lt; ln; i++) {
            series = seriesItems[i];
            delete series._lastItemForPoint;
        }
    },

<span id='Ext-chart-Chart-method-delayRefresh'>    // @private buffered refresh for when we update the store
</span>    delayRefresh: function() {
        var me = this;
        if (!me.refreshTask) {
            me.refreshTask = new Ext.util.DelayedTask(me.refresh, me);
        }
        me.refreshTask.delay(me.refreshBuffer);
    },

<span id='Ext-chart-Chart-method-refresh'>    // @private
</span>    refresh: function() {
        var me = this;
            
        if (me.rendered &amp;&amp; me.curWidth !== undefined &amp;&amp; me.curHeight !== undefined) {
            if (!me.isVisible(true)) {
                if (!me.refreshPending) {
                    me.setShowListeners(&#39;mon&#39;);
                    me.refreshPending = true;
                }
                return;
            }
            if (me.fireEvent(&#39;beforerefresh&#39;, me) !== false) {
                me.redraw();
                me.fireEvent(&#39;refresh&#39;, me);
            }
        }
    },
    
<span id='Ext-chart-Chart-method-onShow'>    onShow: function(){
</span>        var me = this;
        me.callParent(arguments);
        if (me.refreshPending) {
            me.delayRefresh();
            me.setShowListeners(&#39;mun&#39;);
        }
        delete me.refreshPending;
    },
    
<span id='Ext-chart-Chart-method-setShowListeners'>    setShowListeners: function(method){
</span>        var me = this;
        me[method](me.hierarchyEventSource, {
            scope: me,
            single: true,
            show: me.forceRefresh,
            expand: me.forceRefresh
        });
    },
    
<span id='Ext-chart-Chart-method-doRefresh'>    doRefresh: function(){
</span>        // Data in the main store has changed, clear the sub store
        this.setSubStore(null);
        this.refresh();    
    },
    
<span id='Ext-chart-Chart-method-forceRefresh'>    forceRefresh: function(container) {
</span>        var me = this;
        if (me.isDescendantOf(container) &amp;&amp; me.refreshPending) {
            // Add unbind here, because either expand/show could be fired,
            // so be sure to unbind the listener that didn&#39;t
            me.setShowListeners(&#39;mun&#39;);
            me.delayRefresh();
        }    
        delete me.refreshPending;
    },

<span id='Ext-chart-Chart-method-bindStore'>    bindStore: function(store, initial) {
</span>        var me = this;
        me.mixins.bindable.bindStore.apply(me, arguments);
        if (me.store &amp;&amp; !initial) {
            me.refresh();
        }
    },
    
<span id='Ext-chart-Chart-method-getStoreListeners'>    getStoreListeners: function() {
</span>        var refresh = this.doRefresh,
            delayRefresh = this.delayRefresh;
            
        return {
            refresh: refresh,
            add: delayRefresh,
            bulkremove: delayRefresh,
            update: delayRefresh,
            clear: refresh
        };
    },
    
<span id='Ext-chart-Chart-method-setSubStore'>    setSubStore: function(subStore){
</span>        this.substore = subStore;    
    },

<span id='Ext-chart-Chart-method-initializeAxis'>    // @private Create Axis
</span>    initializeAxis: function(axis) {
        var me = this,
            chartBBox = me.chartBBox,
            w = chartBBox.width,
            h = chartBBox.height,
            x = chartBBox.x,
            y = chartBBox.y,
            themeAttrs = me.themeAttrs,
            config = {
                chart: me
            };
        if (themeAttrs) {
            config.axisStyle = Ext.apply({}, themeAttrs.axis);
            config.axisLabelLeftStyle = Ext.apply({}, themeAttrs.axisLabelLeft);
            config.axisLabelRightStyle = Ext.apply({}, themeAttrs.axisLabelRight);
            config.axisLabelTopStyle = Ext.apply({}, themeAttrs.axisLabelTop);
            config.axisLabelBottomStyle = Ext.apply({}, themeAttrs.axisLabelBottom);
            config.axisTitleLeftStyle = Ext.apply({}, themeAttrs.axisTitleLeft);
            config.axisTitleRightStyle = Ext.apply({}, themeAttrs.axisTitleRight);
            config.axisTitleTopStyle = Ext.apply({}, themeAttrs.axisTitleTop);
            config.axisTitleBottomStyle = Ext.apply({}, themeAttrs.axisTitleBottom);
        }
        switch (axis.position) {
            case &#39;top&#39;:
                Ext.apply(config, {
                    length: w,
                    width: h,
                    x: x,
                    y: y
                });
            break;
            case &#39;bottom&#39;:
                Ext.apply(config, {
                    length: w,
                    width: h,
                    x: x,
                    y: h
                });
            break;
            case &#39;left&#39;:
                Ext.apply(config, {
                    length: h,
                    width: w,
                    x: x,
                    y: h
                });
            break;
            case &#39;right&#39;:
                Ext.apply(config, {
                    length: h,
                    width: w,
                    x: w,
                    y: h
                });
            break;
        }
        if (!axis.chart) {
            Ext.apply(config, axis);
            axis = me.axes.replace(Ext.createByAlias(&#39;axis.&#39; + axis.type.toLowerCase(), config));
        } else {
            Ext.apply(axis, config);
        }
        axis.initialized = true;
    },


<span id='Ext-chart-Chart-method-getInsets'>    /**
</span>     * @private Get initial insets; override to provide different defaults.
     */
    getInsets: function() {
        var me = this,
            insetPadding = me.insetPadding;

        return {
            top: insetPadding,
            right: insetPadding,
            bottom: insetPadding,
            left: insetPadding
        };
    },

<span id='Ext-chart-Chart-method-calculateInsets'>    /**
</span>     * @private Calculate insets for the Chart.
     */
    calculateInsets: function() {
        var me = this,
            legend = me.legend,
            axes = me.axes,
            edges = [&#39;top&#39;, &#39;right&#39;, &#39;bottom&#39;, &#39;left&#39;],
            insets, i, l, edge, isVertical, axis, bbox;

        function getAxis(edge) {
            var i = axes.findIndex(&#39;position&#39;, edge);
            return (i &lt; 0) ? null : axes.getAt(i);
        }
        
        insets = me.getInsets();

        // Find the space needed by axes and legend as a positive inset from each edge
        for (i = 0, l = edges.length; i &lt; l; i++) {
            edge = edges[i];
            
            isVertical = (edge === &#39;left&#39; || edge === &#39;right&#39;);
            axis = getAxis(edge);

            // Add legend size if it&#39;s on this edge
            if (legend !== false) {
                if (legend.position === edge) {
                    bbox = legend.getBBox();
                    insets[edge] += (isVertical ? bbox.width : bbox.height) + me.insetPadding;
                }
            }

            // Add axis size if there&#39;s one on this edge only if it has been
            //drawn before.
            if (axis &amp;&amp; axis.bbox) {
                bbox = axis.bbox;
                insets[edge] += (isVertical ? bbox.width : bbox.height);
            }
        };
        
        return insets;
    },

<span id='Ext-chart-Chart-method-alignAxes'>    /**
</span>     * @private Adjust the dimensions and positions of each axis and the chart body area after accounting
     * for the space taken up on each side by the axes and legend.
     * This code is taken from Ext.chart.Chart and refactored to provide better flexibility.
     */
    alignAxes: function() {
        var me = this,
            axesItems = me.axes.items,
            insets, chartBBox, i, l, axis, pos, isVertical;
        
        insets = me.calculateInsets();

        // Build the chart bbox based on the collected inset values
        chartBBox = {
            x: insets.left,
            y: insets.top,
            width: me.curWidth - insets.left - insets.right,
            height: me.curHeight - insets.top - insets.bottom
        };
        me.chartBBox = chartBBox;

        // Go back through each axis and set its length and position based on the
        // corresponding edge of the chartBBox
        for (i = 0, l = axesItems.length; i &lt; l; i++) {
            axis = axesItems[i];
            pos = axis.position;
            isVertical = pos === &#39;left&#39; || pos === &#39;right&#39;;

            axis.x = (pos === &#39;right&#39; ? chartBBox.x + chartBBox.width : chartBBox.x);
            axis.y = (pos === &#39;top&#39; ? chartBBox.y : chartBBox.y + chartBBox.height);
            axis.width = (isVertical ? chartBBox.width : chartBBox.height);
            axis.length = (isVertical ? chartBBox.height : chartBBox.width);
        };
    },

<span id='Ext-chart-Chart-method-initializeSeries'>    // @private initialize the series.
</span>    initializeSeries: function(series, idx, themeIndex) {
        var me = this,
            themeAttrs = me.themeAttrs,
            seriesObj, markerObj, seriesThemes, st,
            markerThemes, colorArrayStyle = [],
            isInstance = (series instanceof Ext.chart.series.Series).
            i = 0, l, config;

        if (!series.initialized) {
            config = {
                chart: me,
                seriesId: series.seriesId
            };
            if (themeAttrs) {
                seriesThemes = themeAttrs.seriesThemes;
                markerThemes = themeAttrs.markerThemes;
                seriesObj = Ext.apply({}, themeAttrs.series);
                markerObj = Ext.apply({}, themeAttrs.marker);
                config.seriesStyle = Ext.apply(seriesObj, seriesThemes[themeIndex % seriesThemes.length]);
                config.seriesLabelStyle = Ext.apply({}, themeAttrs.seriesLabel);
                config.markerStyle = Ext.apply(markerObj, markerThemes[themeIndex % markerThemes.length]);
                if (themeAttrs.colors) {
                    config.colorArrayStyle = themeAttrs.colors;
                } else {
                    colorArrayStyle = [];
                    for (l = seriesThemes.length; i &lt; l; i++) {
                        st = seriesThemes[i];
                        if (st.fill || st.stroke) {
                            colorArrayStyle.push(st.fill || st.stroke);
                        }
                    }
                    if (colorArrayStyle.length) {
                        config.colorArrayStyle = colorArrayStyle;
                    }
                }
                config.seriesIdx = idx;
                config.themeIdx = themeIndex;
            }
            
            if (isInstance) {
                Ext.applyIf(series, config);
            }
            else {
                Ext.applyIf(config, series);
                series = me.series.replace(Ext.createByAlias(&#39;series.&#39; + series.type.toLowerCase(), config));
            }
        }

        if (series.initialize) {
            series.initialize();
        }
        series.initialized = true;
        return series;
    },

<span id='Ext-chart-Chart-method-getMaxGutters'>    // @private
</span>    getMaxGutters: function() {
        var me = this,
            seriesItems = me.series.items,
            i, ln, series, gutters,
            lowerH = 0, upperH = 0, lowerV = 0, upperV = 0;

        for (i = 0, ln = seriesItems.length; i &lt; ln; i++) {
            gutters = seriesItems[i].getGutters();
            if (gutters) {
                if (gutters.verticalAxis) {
                    lowerV = Math.max(lowerV, gutters.lower);
                    upperV = Math.max(upperV, gutters.upper);
                }
                else {
                    lowerH = Math.max(lowerH, gutters.lower);
                    upperH = Math.max(upperH, gutters.upper);
                }
            }
        }
        me.maxGutters = {
            left: lowerH,
            right: upperH,
            bottom: lowerV,
            top: upperV
        };
    },

<span id='Ext-chart-Chart-method-drawAxis'>    // @private draw axis.
</span>    drawAxis: function(axis) {
        axis.drawAxis();
    },

<span id='Ext-chart-Chart-method-drawCharts'>    // @private draw series.
</span>    drawCharts: function(series) {
        series.triggerafterrender = false;
        series.drawSeries();
        if (!this.animate) {
            series.fireEvent(&#39;afterrender&#39;);
        }
    },
<span id='Ext-chart-Chart-method-save'>    /**
</span>     * Saves the chart by either triggering a download or returning a string containing the chart data
     * as SVG.  The action depends on the export type specified in the passed configuration. The chart
     * will be exported using either the {@link Ext.draw.engine.SvgExporter} or the {@link Ext.draw.engine.ImageExporter}
     * classes.
     *
     * Possible export types:
     *
     * - &#39;image/png&#39;
     * - &#39;image/jpeg&#39;,
     * - &#39;image/svg+xml&#39;
     *
     * If &#39;image/svg+xml&#39; is specified, the SvgExporter will be used. 
     * If &#39;image/png&#39; or &#39;image/jpeg&#39; are specified, the ImageExporter will be used. This exporter
     * must post the SVG data to a remote server to have the data processed, see the {@link Ext.draw.engine.ImageExporter}
     * for more details.
     *
     * Example usage:
     *
     *     chart.save({
     *          type: &#39;image/png&#39;
     *     });
     *
     * **Important**: By default, chart data is sent to a server operated
     * by Sencha to do data processing. You may change this default by
     * setting the {@link Ext.draw.engine.ImageExporter#defaultUrl defaultUrl} of the {@link Ext.draw.engine.ImageExporter} class.
     * In addition, please note that this service only creates PNG images.
     *
     * @param {Object} [config] The configuration to be passed to the exporter.
     * See the export method for the appropriate exporter for the relevant
     * configuration options
     * @return {Object} See the return types for the appropriate exporter
     */
    save: function(config){
        return Ext.draw.Surface.save(this.surface, config);
    },
<span id='Ext-chart-Chart-method-destroy'>    // @private remove gently.
</span>    destroy: function() {
        Ext.destroy(this.surface);
        this.bindStore(null);
        this.callParent(arguments);
    }
});
</pre>
</body>
</html>

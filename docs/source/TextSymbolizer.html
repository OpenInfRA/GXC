<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='GXC-form-TextSymbolizer'>/**
</span> * Form for configuring a text symbolizer.
 */
Ext.define(&#39;GXC.form.TextSymbolizer&#39;, {
    extend: &#39;Ext.form.Panel&#39;,
    requires: [
        &#39;Ext.form.FieldSet&#39;,
        &#39;GXC.form.FontComboBox&#39;,
        &#39;GXC.form.TextSymbolizerViewController&#39;
    ],

<span id='GXC-form-TextSymbolizer-property-controller'>    controller: &#39;GXC.form.TextSymbolizerViewController&#39;,
</span>
    alias: &#39;widget.gxc_form_textsymbolizer&#39;,

<span id='GXC-form-TextSymbolizer-property-fonts'>    /**
</span>     *  List of fonts for the font combo.  If not set, defaults to the list
     *  provided by the :class:`gxp.FontComboBox`.
     *
     * @type {[String]}
     */
    fonts: undefined,

<span id='GXC-form-TextSymbolizer-property-symbolizer'>    /**
</span>     *  A symbolizer object that will be used to fill in form values.
     *  This object will be modified when values change.  Clone first if
     *  you do not want your symbolizer modified.
     *
     * @type {Object}
     */
    symbolizer: null,

<span id='GXC-form-TextSymbolizer-property-defaultSymbolizer'>    /**
</span>     *  Default symbolizer properties to be used where none provided.
     *
     * @type {Object}
     */
    defaultSymbolizer: null,

<span id='GXC-form-TextSymbolizer-property-attributes'>    /**
</span>     *  A configured attributes store for use in the filter property combo.
     *
     * @type {GeoExt.data.AttributeStore}
     */
    attributes: null,

<span id='GXC-form-TextSymbolizer-property-labelValuesText'>    /** i18n */
</span>    labelValuesText: &quot;Label values&quot;,
<span id='GXC-form-TextSymbolizer-property-haloText'>    haloText: &quot;Halo&quot;,
</span><span id='GXC-form-TextSymbolizer-property-sizeText'>    sizeText: &quot;Size&quot;,
</span><span id='GXC-form-TextSymbolizer-property-priorityText'>    priorityText: &quot;Priority&quot;,
</span><span id='GXC-form-TextSymbolizer-property-labelOptionsText'>    labelOptionsText: &quot;Label options&quot;,
</span><span id='GXC-form-TextSymbolizer-property-autoWrapText'>    autoWrapText: &quot;Auto wrap&quot;,
</span><span id='GXC-form-TextSymbolizer-property-followLineText'>    followLineText: &quot;Follow line&quot;,
</span><span id='GXC-form-TextSymbolizer-property-maxDisplacementText'>    maxDisplacementText: &quot;Maximum displacement&quot;,
</span><span id='GXC-form-TextSymbolizer-property-repeatText'>    repeatText: &quot;Repeat&quot;,
</span><span id='GXC-form-TextSymbolizer-property-forceLeftToRightText'>    forceLeftToRightText: &quot;Force left to right&quot;,
</span><span id='GXC-form-TextSymbolizer-property-groupText'>    groupText: &quot;Grouping&quot;,
</span><span id='GXC-form-TextSymbolizer-property-spaceAroundText'>    spaceAroundText: &quot;Space around&quot;,
</span><span id='GXC-form-TextSymbolizer-property-labelAllGroupText'>    labelAllGroupText: &quot;Label all segments in line group&quot;,
</span><span id='GXC-form-TextSymbolizer-property-maxAngleDeltaText'>    maxAngleDeltaText: &quot;Maximum angle delta&quot;,
</span><span id='GXC-form-TextSymbolizer-property-conflictResolutionText'>    conflictResolutionText: &quot;Conflict resolution&quot;,
</span><span id='GXC-form-TextSymbolizer-property-goodnessOfFitText'>    goodnessOfFitText: &quot;Goodness of fit&quot;,
</span><span id='GXC-form-TextSymbolizer-property-polygonAlignText'>    polygonAlignText: &quot;Polygon alignment&quot;,
</span><span id='GXC-form-TextSymbolizer-property-graphicResizeText'>    graphicResizeText: &quot;Graphic resize&quot;,
</span><span id='GXC-form-TextSymbolizer-property-graphicMarginText'>    graphicMarginText: &quot;Graphic margin&quot;,
</span><span id='GXC-form-TextSymbolizer-property-graphicTitle'>    graphicTitle: &quot;Graphic&quot;,
</span><span id='GXC-form-TextSymbolizer-property-fontLabel'>    fontLabel: &quot;Font&quot;,
</span><span id='GXC-form-TextSymbolizer-property-fontColorTitle'>    fontColorTitle: &quot;Font color and opacity&quot;,
</span><span id='GXC-form-TextSymbolizer-property-positioningText'>    positioningText: &quot;Label positioning&quot;,
</span><span id='GXC-form-TextSymbolizer-property-anchorPointText'>    anchorPointText: &quot;Anchor point&quot;,
</span><span id='GXC-form-TextSymbolizer-property-displacementXText'>    displacementXText: &quot;Displacement (X-direction)&quot;,
</span><span id='GXC-form-TextSymbolizer-property-displacementYText'>    displacementYText: &quot;Displacement (Y-direction)&quot;,
</span><span id='GXC-form-TextSymbolizer-property-perpendicularOffsetText'>    perpendicularOffsetText: &quot;Perpendicular offset&quot;,
</span><span id='GXC-form-TextSymbolizer-property-priorityHelp'>    priorityHelp: &quot;The higher the value of the specified field, the sooner the label will be drawn (which makes it win in the conflict resolution game)&quot;,
</span><span id='GXC-form-TextSymbolizer-property-autoWrapHelp'>    autoWrapHelp: &quot;Wrap labels that exceed a certain length in pixels&quot;,
</span><span id='GXC-form-TextSymbolizer-property-followLineHelp'>    followLineHelp: &quot;Should the label follow the geometry of the line?&quot;,
</span><span id='GXC-form-TextSymbolizer-property-maxDisplacementHelp'>    maxDisplacementHelp: &quot;Maximum displacement in pixels if label position is busy&quot;,
</span><span id='GXC-form-TextSymbolizer-property-repeatHelp'>    repeatHelp: &quot;Repeat labels after a certain number of pixels&quot;,
</span><span id='GXC-form-TextSymbolizer-property-forceLeftToRightHelp'>    forceLeftToRightHelp: &quot;Labels are usually flipped to make them readable. If the character happens to be a directional arrow then this is not desirable&quot;,
</span><span id='GXC-form-TextSymbolizer-property-groupHelp'>    groupHelp: &quot;Grouping works by collecting all features with the same label text, then choosing a representative geometry for the group. Road data is a classic example to show why grouping is useful. It is usually desirable to display only a single label for all of &#39;Main Street&#39;, not a label for every block of &#39;Main Street.&#39;&quot;,
</span><span id='GXC-form-TextSymbolizer-property-spaceAroundHelp'>    spaceAroundHelp: &quot;Overlapping and Separating Labels. By default GeoServer will not render labels &#39;on top of each other&#39;. By using the spaceAround option you can either allow labels to overlap, or add extra space around labels. The value supplied for the option is a positive or negative size in pixels. Using the default value of 0, the bounding box of a label cannot overlap the bounding box of another label.&quot;,
</span><span id='GXC-form-TextSymbolizer-property-labelAllGroupHelp'>    labelAllGroupHelp: &quot;The labelAllGroup option makes sure that all of the segments in a line group are labeled instead of just the longest one.&quot;,
</span><span id='GXC-form-TextSymbolizer-property-conflictResolutionHelp'>    conflictResolutionHelp: &quot;By default labels are subjected to conflict resolution, meaning the renderer will not allow any label to overlap with a label that has been drawn already. Setting this parameter to false pull the label out of the conflict resolution game, meaning the label will be drawn even if it overlaps with other labels, and other labels drawn after it won’t mind overlapping with it.&quot;,
</span><span id='GXC-form-TextSymbolizer-property-goodnessOfFitHelp'>    goodnessOfFitHelp: &quot;Geoserver will remove labels if they are a particularly bad fit for the geometry they are labeling. For Polygons: the label is sampled approximately at every letter. The distance from these points to the polygon is determined and each sample votes based on how close it is to the polygon. The default value is 0.5.&quot;,
</span><span id='GXC-form-TextSymbolizer-property-graphicResizeHelp'>    graphicResizeHelp: &quot;Specifies a mode for resizing label graphics (such as highway shields) to fit the text of the label. The default mode, ‘none’, never modifies the label graphic. In stretch mode, GeoServer will resize the graphic to exactly surround the label text, possibly modifying the image’s aspect ratio. In proportional mode, GeoServer will expand the image to be large enough to surround the text while preserving its original aspect ratio.&quot;,
</span><span id='GXC-form-TextSymbolizer-property-maxAngleDeltaHelp'>    maxAngleDeltaHelp: &quot;Designed to use used in conjuection with followLine, the maxAngleDelta option sets the maximum angle, in degrees, between two subsequent characters in a curved label. Large angles create either visually disconnected words or overlapping characters. It is advised not to use angles larger than 30.&quot;,
</span><span id='GXC-form-TextSymbolizer-property-polygonAlignHelp'>    polygonAlignHelp: &quot;GeoServer normally tries to place horizontal labels within a polygon, and give up in case the label position is busy or if the label does not fit enough in the polygon. This options allows GeoServer to try alternate rotations for the labels. Possible options: the default value, only the rotation manually specified in the &lt;Rotation&gt; tag will be used (manual), If the label does not fit horizontally and the polygon is taller than wider the vertical alignement will also be tried (ortho), If the label does not fit horizontally the minimum bounding rectangle will be computed and a label aligned to it will be tried out as well (mbr).&quot;,
</span><span id='GXC-form-TextSymbolizer-property-graphicMarginHelp'>    graphicMarginHelp: &quot;Similar to the margin shorthand property in CSS for HTML, its interpretation varies depending on how many margin values are provided: 1 = use that margin length on all sides of the label 2 = use the first for top &amp; bottom margins and the second for left &amp; right margins. 3 = use the first for the top margin, second for left &amp; right margins, third for the bottom margin. 4 = use the first for the top margin, second for the right margin, third for the bottom margin, and fourth for the left margin.&quot;,
</span>
<span id='GXC-form-TextSymbolizer-cfg-fieldDefaults'>    fieldDefaults: {
</span>        anchor: &#39;100%&#39;
    },
<span id='GXC-form-TextSymbolizer-cfg-border'>    border: false,
</span>
<span id='GXC-form-TextSymbolizer-method-initComponent'>    initComponent: function() {
</span>
        if (!this.symbolizer) {
            this.symbolizer = {};
        }
        Ext.applyIf(this.symbolizer, this.defaultSymbolizer);

        if (!this.symbolizer.vendorOptions) {
            this.symbolizer.vendorOptions = {};
        }

        this.attributes.on(&#39;load&#39;, this.showHideGeometryOptions, this);
        this.attributes.load();

        this.attributesComboConfig = {
            itemId: &#39;attributesCombo&#39;,
            xtype: &quot;combo&quot;,
            fieldLabel: this.labelValuesText,
            store: this.attributes,
            mode: &#39;local&#39;,
            lastQuery: &#39;&#39;,
            editable: false,
            triggerAction: &quot;all&quot;,
            allowBlank: false,
            displayField: &quot;name&quot;,
            valueField: &quot;name&quot;,
            value: this.symbolizer.label &amp;&amp;
                   this.symbolizer.label.replace(/^\${(.*)}$/, &quot;$1&quot;)
        };

        this.items = [
            this.attributesComboConfig, {
                itemId: &#39;fontCombo&#39;,
                xtype: &quot;gxc_form_fontcombobox&quot;,
                fieldLabel: this.fontLabel,
                fonts: this.fonts || undefined,
                value: this.symbolizer.fontFamily
            }, {
                itemId: &#39;fontSizeField&#39;,
                xtype: &quot;numberfield&quot;,
                fieldLabel: this.sizeText,
                allowNegative: false,
                emptyText: OpenLayers.Renderer.defaultSymbolizer.fontSize,
                value: this.symbolizer.fontSize
            }, {
                itemId: &#39;fontWeightButton&#39;,
                xtype: &#39;button&#39;,
                enableToggle: true,
                iconCls: &quot;gxc-icon-bold&quot;,
                pressed: this.symbolizer.fontWeight === &quot;bold&quot;
            }, {
                itemId: &#39;fontStyleButton&#39;,
                xtype: &#39;button&#39;,
                enableToggle: true,
                iconCls: &quot;gxc-icon-italic&quot;,
                pressed: this.symbolizer.fontStyle === &quot;italic&quot;
            }, {
                itemId: &#39;fontColorSymbolizer&#39;,
                xtype: &quot;gxc_form_fillsymbolizer&quot;,
                fillText: this.fontColorTitle,
                symbolizer: this.symbolizer,
                colorProperty: &quot;fontColor&quot;,
                opacityProperty: &quot;fontOpacity&quot;,
                checkboxToggle: false,
                autoHeight: true
            }, {
                itemId: &#39;graphicFieldSet&#39;,
                xtype: &quot;fieldset&quot;,
                title: this.graphicTitle,
                checkboxToggle: true,
                hideMode: &#39;offsets&#39;,
                collapsed: !(this.symbolizer.fillColor ||
                    this.symbolizer.fillOpacity ||
                    this.symbolizer.vendorOptions[&quot;graphic-resize&quot;] ||
                    this.symbolizer.vendorOptions[&quot;graphic-margin&quot;]
                ),
                items: [{
                    itemId: &#39;fontGraphicSymbolizer&#39;,
                    xtype: &quot;gxc_panel_pointsymbolizer&quot;,
                    border: false,
                    symbolizer: this.symbolizer
                },
                this.createVendorSpecificField({
                    itemId: &#39;graphicResizeCombo&#39;,
                    name: &quot;graphic-resize&quot;,
                    xtype: &quot;combo&quot;,
                    store: [
                        &quot;none&quot;,
                        &quot;stretch&quot;,
                        &quot;proportional&quot;
                    ],
                    mode: &#39;local&#39;,
                    triggerAction: &#39;all&#39;,
                    fieldLabel: this.graphicResizeText
                }),
                this.createVendorSpecificField({
                    itemId: &#39;graphicMarginField&#39;,
                    xtype: &quot;textfield&quot;,
                    name: &quot;graphic-margin&quot;,
                    hidden: (
                        this.symbolizer.vendorOptions[&quot;graphic-resize&quot;] !== &quot;stretch&quot; &amp;&amp;
                        this.symbolizer.vendorOptions[&quot;graphic-resize&quot;] !== &quot;proportional&quot;
                    ),
                    fieldLabel: this.graphicMarginText
                })]
            }, {
                itemId: &#39;haloFieldSet&#39;,
                xtype: &quot;fieldset&quot;,
                title: this.haloText,
                checkboxToggle: true,
                collapsed: !(this.symbolizer.haloRadius ||
                    this.symbolizer.haloColor ||
                    this.symbolizer.haloOpacity
                ),
                autoHeight: true,
                items: [{
                    itemId: &#39;haloRadiusField&#39;,
                    xtype: &quot;numberfield&quot;,
                    fieldLabel: this.sizeText,
                    allowNegative: false,
                    emptyText: OpenLayers.Renderer.defaultSymbolizer.haloRadius,
                    value: this.symbolizer.haloRadius
                }, {
                    itemId: &#39;haloColorSymbolizer&#39;,
                    xtype: &quot;gxc_form_fillsymbolizer&quot;,
                    symbolizer: {
                        fillColor: (&quot;haloColor&quot; in this.symbolizer) ?
                            this.symbolizer.haloColor :
                            OpenLayers.Renderer.defaultSymbolizer.haloColor,
                        fillOpacity: (&quot;haloOpacity&quot; in this.symbolizer) ?
                            this.symbolizer.haloOpacity :
                            OpenLayers.Renderer.defaultSymbolizer.haloOpacity * 100
                    },
                    defaultColor: OpenLayers.Renderer.defaultSymbolizer.haloColor,
                    checkboxToggle: false
                }]
            }, {
                xtype: &quot;fieldset&quot;,
                collapsed: !(this.symbolizer.labelAlign ||
                    this.symbolizer.vendorOptions[&#39;polygonAlign&#39;] ||
                    this.symbolizer.labelXOffset ||
                    this.symbolizer.labelYOffset ||
                    this.symbolizer.labelPerpendicularOffset
                ),
                title: this.positioningText,
                checkboxToggle: true,
                autoHeight: true,
                items: [
                    this.createField(Ext.applyIf({
                        itemId: &#39;pointLabelAlignCombo&#39;,
                        fieldLabel: this.anchorPointText,
                        geometryTypes: [&quot;POINT&quot;],
                        value: this.symbolizer.labelAlign || &quot;lb&quot;,
                        store: [
                            [&#39;lt&#39;, &#39;Left-top&#39;],
                            [&#39;ct&#39;, &#39;Center-top&#39;],
                            [&#39;rt&#39;, &#39;Right-top&#39;],
                            [&#39;lm&#39;, &#39;Left-center&#39;],
                            [&#39;cm&#39;, &#39;Center&#39;],
                            [&#39;rm&#39;, &#39;Right-center&#39;],
                            [&#39;lb&#39;, &#39;Left-bottom&#39;],
                            [&#39;cb&#39;, &#39;Center-bottom&#39;],
                            [&#39;rb&#39;, &#39;Right-bottom&#39;]
                        ]
                    }, this.attributesComboConfig)),
                    this.createField({
                        itemId: &#39;displamcementXField&#39;,
                        xtype: &quot;numberfield&quot;,
                        geometryTypes: [&quot;POINT&quot;],
                        fieldLabel: this.displacementXText,
                        value: this.symbolizer.labelXOffset
                    }),
                    this.createField({
                        itemId: &#39;displamcementYField&#39;,
                        xtype: &quot;numberfield&quot;,
                        geometryTypes: [&quot;POINT&quot;],
                        fieldLabel: this.displacementYText,
                        value: this.symbolizer.labelYOffset
                    }),
                    this.createField({
                        itemId: &#39;perpendicularOffsetField&#39;,
                        xtype: &quot;numberfield&quot;,
                        geometryTypes: [&quot;LINE&quot;],
                        fieldLabel: this.perpendicularOffsetText,
                        value: this.symbolizer.labelPerpendicularOffset
                    }),
                    this.createVendorSpecificField({
                        itemId: &#39;polygonAlignCombo&#39;,
                        name: &#39;polygonAlign&#39;,
                        geometryTypes: [&#39;POLYGON&#39;],
                        xtype: &quot;combo&quot;,
                        mode: &#39;local&#39;,
                        value: this.symbolizer.vendorOptions[&#39;polygonAlign&#39;] ||
                               &#39;manual&#39;,
                        triggerAction: &#39;all&#39;,
                        store: [
                            &quot;manual&quot;,
                            &quot;ortho&quot;,
                            &quot;mbr&quot;
                        ],
                        fieldLabel: this.polygonAlignText
                    })
                ]
            }, {
                xtype: &quot;fieldset&quot;,
                title: this.priorityText,
                checkboxToggle: true,
                collapsed: !(this.symbolizer.priority),
                autoHeight: true,
                items: [
                    Ext.applyIf({
                        itemId: &#39;priorityCombo&#39;,
                        fieldLabel: this.priorityText,
                        value: this.symbolizer.priority &amp;&amp;
                            this.symbolizer.priority.replace(/^\${(.*)}$/, &quot;$1&quot;),
                        allowBlank: true,
                        name: &#39;priority&#39;
                    }, this.attributesComboConfig)
                ]
            }, {
                xtype: &quot;fieldset&quot;,
                title: this.labelOptionsText,
                checkboxToggle: true,
                collapsed: !(this.symbolizer.vendorOptions[&#39;autoWrap&#39;] ||
                    this.symbolizer.vendorOptions[&#39;followLine&#39;] ||
                    this.symbolizer.vendorOptions[&#39;maxAngleDelta&#39;] ||
                    this.symbolizer.vendorOptions[&#39;maxDisplacement&#39;] ||
                    this.symbolizer.vendorOptions[&#39;repeat&#39;] ||
                    this.symbolizer.vendorOptions[&#39;forceLeftToRight&#39;] ||
                    this.symbolizer.vendorOptions[&#39;group&#39;] ||
                    this.symbolizer.vendorOptions[&#39;spaceAround&#39;] ||
                    this.symbolizer.vendorOptions[&#39;labelAllGroup&#39;] ||
                    this.symbolizer.vendorOptions[&#39;conflictResolution&#39;] ||
                    this.symbolizer.vendorOptions[&#39;goodnessOfFit&#39;] ||
                    this.symbolizer.vendorOptions[&#39;polygonAlign&#39;]
                ),
                autoHeight: true,
                items: [
                    this.createVendorSpecificField({
                        itemId: &#39;autoWrapField&#39;,
                        name: &#39;autoWrap&#39;,
                        allowBlank: false,
                        fieldLabel: this.autoWrapText
                    }),
                    this.createVendorSpecificField({
                        itemId: &#39;followLineField&#39;,
                        name: &#39;followLine&#39;,
                        geometryTypes: [&quot;LINE&quot;],
                        xtype: &#39;checkbox&#39;,
                        fieldLabel: this.followLineText
                    }),
                    this.createVendorSpecificField({
                        itemId: &#39;maxAngleDeltaField&#39;,
                        name: &#39;maxAngleDelta&#39;,
                        hidden: (
                            this.symbolizer.vendorOptions[&quot;followLine&quot;] == null
                        ),
                        geometryTypes: [&quot;LINE&quot;],
                        fieldLabel: this.maxAngleDeltaText
                    }),
                    this.createVendorSpecificField({
                        itemId: &#39;maxDisplacementField&#39;,
                        name: &#39;maxDisplacement&#39;,
                        fieldLabel: this.maxDisplacementText
                    }),
                    this.createVendorSpecificField({
                        itemId: &#39;repeatField&#39;,
                        name: &#39;repeat&#39;,
                        geometryTypes: [&quot;LINE&quot;],
                        fieldLabel: this.repeatText
                    }),
                    this.createVendorSpecificField({
                        itemId: &#39;forceLeftToRightField&#39;,
                        name: &#39;forceLeftToRight&#39;,
                        xtype: &quot;checkbox&quot;,
                        geometryTypes: [&quot;LINE&quot;],
                        fieldLabel: this.forceLeftToRightText
                    }),
                    this.createVendorSpecificField({
                        itemId: &#39;groupField&#39;,
                        name: &#39;group&#39;,
                        xtype: &#39;checkbox&#39;,
                        yesno: true,
                        fieldLabel: this.groupText
                    }),
                    this.createVendorSpecificField({
                        itemId: &#39;labelAllGroupField&#39;,
                        name: &#39;labelAllGroup&#39;,
                        geometryTypes: [&quot;LINE&quot;],
                        hidden: (this.symbolizer.vendorOptions[&#39;group&#39;] !== &#39;yes&#39;),
                        xtype: &quot;checkbox&quot;,
                        fieldLabel: this.labelAllGroupText
                    }),
                    this.createVendorSpecificField({
                        itemId: &#39;conflictResolutionField&#39;,
                        name: &#39;conflictResolution&#39;,
                        xtype: &quot;checkbox&quot;,
                        fieldLabel: this.conflictResolutionText
                    }),
                    this.createVendorSpecificField({
                        itemId: &#39;spaceAroundField&#39;,
                        name: &#39;spaceAround&#39;,
                        hidden: (
                            this.symbolizer.vendorOptions[&#39;conflictResolution&#39;] !== true
                        ),
                        allowNegative: true,
                        fieldLabel: this.spaceAroundText
                    }),
                    this.createVendorSpecificField({
                        itemId: &#39;goodnessOfFitField&#39;,
                        name: &#39;goodnessOfFit&#39;,
                        geometryTypes: [&#39;POLYGON&#39;],
                        fieldLabel: this.goodnessOfFitText
                    })
                ]
            }
        ];

        this.addEvents(
<span id='GXC-form-TextSymbolizer-property-change'>            /**
</span>             * Event: change
             * Fires before any field blurs if the field value has changed.
             *
             * Listener arguments:
             * symbolizer - {Object} A symbolizer with text related properties
             *     updated.
             */
            &quot;change&quot;
        );

        this.callParent(arguments);

    },

<span id='GXC-form-TextSymbolizer-method-createField'>    createField: function(config) {
</span>        var field = Ext.ComponentMgr.create(config);

        if (config.geometryTypes) {
            this.on(&#39;geometrytype&#39;, function(type) {
                if (config.geometryTypes.indexOf(type) === -1) {
                    field.hide();
                }
            });
        }

        return field;
    },

<span id='GXC-form-TextSymbolizer-method-createVendorSpecificField'>    /**
</span>     *  Create a form field that will generate a VendorSpecific tag.
     *
     * @private
     */
    createVendorSpecificField: function(config) {
        var field;

        Ext.applyIf(config, {
            xtype: &quot;numberfield&quot;,
            allowNegative: false,
            value: config.value || this.symbolizer.vendorOptions[config.name],
            checked: (config.yesno === true) ?
                (this.symbolizer.vendorOptions[config.name] === &#39;yes&#39;) :
                this.symbolizer.vendorOptions[config.name]
        });

        field = Ext.ComponentManager.create(config);

        if (config.geometryTypes) {
            this.on(&#39;geometrytype&#39;, function(type) {
                if (config.geometryTypes.indexOf(type) === -1) {
                    field.hide();
                }
            });
        }

        return field;
    },

<span id='GXC-form-TextSymbolizer-method-showHideGeometryOptions'>    showHideGeometryOptions: function() {
</span>        var geomRegex = /gml:((Multi)?(Point|Line|Polygon|Curve|Surface|Geometry)).*/;
        var polygonRegex = /gml:((Multi)?(Polygon|Surface)).*/;
        var pointRegex = /gml:((Multi)?(Point)).*/;
        var lineRegex = /gml:((Multi)?(Line|Curve|Surface)).*/;
        var geomType = null;
        this.attributes.each(function(r) {
            var type = r.get(&quot;type&quot;);
            var match = geomRegex.exec(type);
            if (match) {
                if (polygonRegex.exec(type)) {
                    geomType = &quot;POLYGON&quot;;
                } else if (pointRegex.exec(type)) {
                    geomType = &quot;POINT&quot;;
                } else if (lineRegex.exec(type)) {
                    geomType = &quot;LINE&quot;;
                }
            }
        }, this);

        if (geomType !== null) {
            this.geometryType = geomType;
            this.fireEvent(&#39;geometrytype&#39;, geomType);
        }
    }

});
</pre>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
This file is part of Ext JS 4.2

Copyright (c) 2011-2013 Sencha Inc

Contact:  http://www.sencha.com/contact

GNU General Public License Usage
This file may be used under the terms of the GNU General Public License version 3.0 as
published by the Free Software Foundation and appearing in the file LICENSE included in the
packaging of this file.

Please review the following information to ensure the GNU General Public License version 3.0
requirements will be met: http://www.gnu.org/copyleft/gpl.html.

If you are unsure which license is appropriate for your use, please contact the sales department
at http://www.sencha.com/contact.

Build date: 2013-05-16 14:36:50 (f9be68accb407158ba2b1be2c226a6ce1f649314)
*/
// @tag dom,core
// @define Ext.DomHelper

// @define Ext.core.DomHelper

<span id='Ext-DomHelper'>/**
</span> * @class Ext.DomHelper
 * @extends Ext.dom.Helper
 * @alternateClassName Ext.core.DomHelper
 * @singleton
 *
 * The DomHelper class provides a layer of abstraction from DOM and transparently supports creating elements via DOM or
 * using HTML fragments. It also has the ability to create HTML fragment templates from your DOM building code.
 *
 * # DomHelper element specification object
 *
 * A specification object is used when creating elements. Attributes of this object are assumed to be element
 * attributes, except for 4 special attributes:
 *
 * - **tag** - The tag name of the element.
 * - **children** or **cn** - An array of the same kind of element definition objects to be created and appended.
 *   These can be nested as deep as you want.
 * - **cls** - The class attribute of the element. This will end up being either the &quot;class&quot; attribute on a HTML
 *   fragment or className for a DOM node, depending on whether DomHelper is using fragments or DOM.
 * - **html** - The innerHTML for the element.
 *
 * **NOTE:** For other arbitrary attributes, the value will currently **not** be automatically HTML-escaped prior to
 * building the element&#39;s HTML string. This means that if your attribute value contains special characters that would
 * not normally be allowed in a double-quoted attribute value, you **must** manually HTML-encode it beforehand (see
 * {@link Ext.String#htmlEncode}) or risk malformed HTML being created. This behavior may change in a future release.
 *
 * # Insertion methods
 *
 * Commonly used insertion methods:
 *
 * - **{@link #append}**
 * - **{@link #insertBefore}**
 * - **{@link #insertAfter}**
 * - **{@link #overwrite}**
 * - **{@link #createTemplate}**
 * - **{@link #insertHtml}**
 *
 * # Example
 *
 * This is an example, where an unordered list with 3 children items is appended to an existing element with
 * id &#39;my-div&#39;:
 *
 *     var dh = Ext.DomHelper; // create shorthand alias
 *     // specification object
 *     var spec = {
 *         id: &#39;my-ul&#39;,
 *         tag: &#39;ul&#39;,
 *         cls: &#39;my-list&#39;,
 *         // append children after creating
 *         children: [     // may also specify &#39;cn&#39; instead of &#39;children&#39;
 *             {tag: &#39;li&#39;, id: &#39;item0&#39;, html: &#39;List Item 0&#39;},
 *             {tag: &#39;li&#39;, id: &#39;item1&#39;, html: &#39;List Item 1&#39;},
 *             {tag: &#39;li&#39;, id: &#39;item2&#39;, html: &#39;List Item 2&#39;}
 *         ]
 *     };
 *     var list = dh.append(
 *         &#39;my-div&#39;, // the context element &#39;my-div&#39; can either be the id or the actual node
 *         spec      // the specification object
 *     );
 *
 * Element creation specification parameters in this class may also be passed as an Array of specification objects. This
 * can be used to insert multiple sibling nodes into an existing container very efficiently. For example, to add more
 * list items to the example above:
 *
 *     dh.append(&#39;my-ul&#39;, [
 *         {tag: &#39;li&#39;, id: &#39;item3&#39;, html: &#39;List Item 3&#39;},
 *         {tag: &#39;li&#39;, id: &#39;item4&#39;, html: &#39;List Item 4&#39;}
 *     ]);
 *
 * # Templating
 *
 * The real power is in the built-in templating. Instead of creating or appending any elements, {@link #createTemplate}
 * returns a Template object which can be used over and over to insert new elements. Revisiting the example above, we
 * could utilize templating this time:
 *
 *     // create the node
 *     var list = dh.append(&#39;my-div&#39;, {tag: &#39;ul&#39;, cls: &#39;my-list&#39;});
 *     // get template
 *     var tpl = dh.createTemplate({tag: &#39;li&#39;, id: &#39;item{0}&#39;, html: &#39;List Item {0}&#39;});
 *
 *     for(var i = 0; i &lt; 5, i++){
 *         tpl.append(list, [i]); // use template to append to the actual node
 *     }
 *
 * An example using a template:
 *
 *     var html = &#39;&lt;a id=&quot;{0}&quot; href=&quot;{1}&quot; class=&quot;nav&quot;&gt;{2}&lt;/a&gt;&#39;;
 *
 *     var tpl = new Ext.DomHelper.createTemplate(html);
 *     tpl.append(&#39;blog-roll&#39;, [&#39;link1&#39;, &#39;http://www.edspencer.net/&#39;, &quot;Ed&#39;s Site&quot;]);
 *     tpl.append(&#39;blog-roll&#39;, [&#39;link2&#39;, &#39;http://www.dustindiaz.com/&#39;, &quot;Dustin&#39;s Site&quot;]);
 *
 * The same example using named parameters:
 *
 *     var html = &#39;&lt;a id=&quot;{id}&quot; href=&quot;{url}&quot; class=&quot;nav&quot;&gt;{text}&lt;/a&gt;&#39;;
 *
 *     var tpl = new Ext.DomHelper.createTemplate(html);
 *     tpl.append(&#39;blog-roll&#39;, {
 *         id: &#39;link1&#39;,
 *         url: &#39;http://www.edspencer.net/&#39;,
 *         text: &quot;Ed&#39;s Site&quot;
 *     });
 *     tpl.append(&#39;blog-roll&#39;, {
 *         id: &#39;link2&#39;,
 *         url: &#39;http://www.dustindiaz.com/&#39;,
 *         text: &quot;Dustin&#39;s Site&quot;
 *     });
 *
 * # Compiling Templates
 *
 * Templates are applied using regular expressions. The performance is great, but if you are adding a bunch of DOM
 * elements using the same template, you can increase performance even further by {@link Ext.Template#compile
 * &quot;compiling&quot;} the template. The way &quot;{@link Ext.Template#compile compile()}&quot; works is the template is parsed and
 * broken up at the different variable points and a dynamic function is created and eval&#39;ed. The generated function
 * performs string concatenation of these parts and the passed variables instead of using regular expressions.
 *
 *     var html = &#39;&lt;a id=&quot;{id}&quot; href=&quot;{url}&quot; class=&quot;nav&quot;&gt;{text}&lt;/a&gt;&#39;;
 *
 *     var tpl = new Ext.DomHelper.createTemplate(html);
 *     tpl.compile();
 *
 *     //... use template like normal
 *
 * # Performance Boost
 *
 * DomHelper will transparently create HTML fragments when it can. Using HTML fragments instead of DOM can significantly
 * boost performance.
 *
 * Element creation specification parameters may also be strings. If {@link #useDom} is false, then the string is used
 * as innerHTML. If {@link #useDom} is true, a string specification results in the creation of a text node. Usage:
 *
 *     Ext.DomHelper.useDom = true; // force it to use DOM; reduces performance
 *
 */
Ext.define(&#39;Ext.dom.Helper&#39;, (function() {

// kill repeat to save bytes
var afterbegin = &#39;afterbegin&#39;,
    afterend = &#39;afterend&#39;,
    beforebegin = &#39;beforebegin&#39;,
    beforeend = &#39;beforeend&#39;,
    ts = &#39;&lt;table&gt;&#39;,
    te = &#39;&lt;/table&gt;&#39;,
    tbs = ts+&#39;&lt;tbody&gt;&#39;,
    tbe = &#39;&lt;/tbody&gt;&#39;+te,
    trs = tbs + &#39;&lt;tr&gt;&#39;,
    tre = &#39;&lt;/tr&gt;&#39;+tbe,
    detachedDiv = document.createElement(&#39;div&#39;),
    bbValues = [&#39;BeforeBegin&#39;, &#39;previousSibling&#39;],
    aeValues = [&#39;AfterEnd&#39;, &#39;nextSibling&#39;],
    bb_ae_PositionHash = {
        beforebegin: bbValues,
        afterend: aeValues
    },
    fullPositionHash = {
        beforebegin: bbValues,
        afterend: aeValues,
        afterbegin: [&#39;AfterBegin&#39;, &#39;firstChild&#39;],
        beforeend: [&#39;BeforeEnd&#39;, &#39;lastChild&#39;]
    };

<span id='Ext-dom-Helper'>/**
</span> * @class Ext.dom.Helper
 * @extends Ext.dom.AbstractHelper
 * @requires Ext.dom.AbstractElement
 * 
 * The actual class of which {@link Ext.DomHelper} is instance of.
 * 
 * Use singleton {@link Ext.DomHelper} instead.
 * 
 * @private
 */
return {
    extend: &#39;Ext.dom.AbstractHelper&#39;,
    requires:[&#39;Ext.dom.AbstractElement&#39;],

    tableRe: /^(?:table|thead|tbody|tr|td)$/i,

    tableElRe: /td|tr|tbody|thead/i,

<span id='Ext-dom-Helper-property-useDom'>    /**
</span>     * @property {Boolean} useDom
     * True to force the use of DOM instead of html fragments.
     */
    useDom : false,

<span id='Ext-dom-Helper-method-createDom'>    /**
</span>     * Creates new DOM element(s) without inserting them to the document.
     * @param {Object/String} o The DOM object spec (and children) or raw HTML blob
     * @return {HTMLElement} The new uninserted node
     */
    createDom: function(o, parentNode){
        var el,
            doc = document,
            useSet,
            attr,
            val,
            cn,
            i, l;

        if (Ext.isArray(o)) {                       // Allow Arrays of siblings to be inserted
            el = doc.createDocumentFragment(); // in one shot using a DocumentFragment
            for (i = 0, l = o.length; i &lt; l; i++) {
                this.createDom(o[i], el);
            }
        } else if (typeof o == &#39;string&#39;) {         // Allow a string as a child spec.
            el = doc.createTextNode(o);
        } else {
            el = doc.createElement(o.tag || &#39;div&#39;);
            useSet = !!el.setAttribute; // In IE some elements don&#39;t have setAttribute
            for (attr in o) {
                if (!this.confRe.test(attr)) {
                    val = o[attr];
                    if (attr == &#39;cls&#39;) {
                        el.className = val;
                    } else {
                        if (useSet) {
                            el.setAttribute(attr, val);
                        } else {
                            el[attr] = val;
                        }
                    }
                }
            }
            Ext.DomHelper.applyStyles(el, o.style);

            if ((cn = o.children || o.cn)) {
                this.createDom(cn, el);
            } else if (o.html) {
                el.innerHTML = o.html;
            }
        }
        if (parentNode) {
            parentNode.appendChild(el);
        }
        return el;
    },

    ieTable: function(depth, openingTags, htmlContent, closingTags){
        detachedDiv.innerHTML = [openingTags, htmlContent, closingTags].join(&#39;&#39;);

        var i = -1,
            el = detachedDiv,
            ns;

        while (++i &lt; depth) {
            el = el.firstChild;
        }
        // If the result is multiple siblings, then encapsulate them into one fragment.
        ns = el.nextSibling;

        if (ns) {
            ns = el;
            el = document.createDocumentFragment();
            
            while (ns) {
                 nx = ns.nextSibling;
                 el.appendChild(ns);
                 ns = nx;
            }
        }
        return el;
    },

<span id='Ext-dom-Helper-method-insertIntoTable'>    /**
</span>     * @private
     * Nasty code for IE&#39;s broken table implementation
     */
    insertIntoTable: function(tag, where, destinationEl, html) {
        var node,
            before,
            bb = where == beforebegin,
            ab = where == afterbegin,
            be = where == beforeend,
            ae = where == afterend;

        if (tag == &#39;td&#39; &amp;&amp; (ab || be) || !this.tableElRe.test(tag) &amp;&amp; (bb || ae)) {
            return null;
        }
        before = bb ? destinationEl :
                 ae ? destinationEl.nextSibling :
                 ab ? destinationEl.firstChild : null;

        if (bb || ae) {
            destinationEl = destinationEl.parentNode;
        }

        if (tag == &#39;td&#39; || (tag == &#39;tr&#39; &amp;&amp; (be || ab))) {
            node = this.ieTable(4, trs, html, tre);
        } else if (((tag == &#39;tbody&#39; || tag == &#39;thead&#39;) &amp;&amp; (be || ab)) ||
                (tag == &#39;tr&#39; &amp;&amp; (bb || ae))) {
            node = this.ieTable(3, tbs, html, tbe);
        } else {
            node = this.ieTable(2, ts, html, te);
        }
        destinationEl.insertBefore(node, before);
        return node;
    },

<span id='Ext-dom-Helper-method-createContextualFragment'>    /**
</span>     * @private
     * Fix for IE9 createContextualFragment missing method
     */
    createContextualFragment: function(html) {
        var fragment = document.createDocumentFragment(),
            length, childNodes;

        detachedDiv.innerHTML = html;
        childNodes = detachedDiv.childNodes;
        length = childNodes.length;

        // Move nodes into fragment, don&#39;t clone: http://jsperf.com/create-fragment
        while (length--) {
            fragment.appendChild(childNodes[0]);
        }
        return fragment;
    },

    applyStyles: function(el, styles) {
        if (styles) {
            if (typeof styles == &quot;function&quot;) {
                styles = styles.call();
            }
            if (typeof styles == &quot;string&quot;) {
                styles = Ext.dom.Element.parseStyles(styles);
            }
            if (typeof styles == &quot;object&quot;) {
                Ext.fly(el, &#39;_applyStyles&#39;).setStyle(styles);
            }
        }
    },

<span id='Ext-dom-Helper-method-createHtml'>    /**
</span>     * Alias for {@link #markup}.
     * @inheritdoc Ext.dom.AbstractHelper#markup
     */
    createHtml: function(spec) {
        return this.markup(spec);
    },

    doInsert: function(el, o, returnElement, pos, sibling, append) {
        
        el = el.dom || Ext.getDom(el);

        var newNode;

        if (this.useDom) {
            newNode = this.createDom(o, null);

            if (append) {
                el.appendChild(newNode);
            }
            else {
                (sibling == &#39;firstChild&#39; ? el : el.parentNode).insertBefore(newNode, el[sibling] || el);
            }

        } else {
            newNode = this.insertHtml(pos, el, this.markup(o));
        }
        return returnElement ? Ext.get(newNode, true) : newNode;
    },

<span id='Ext-dom-Helper-method-overwrite'>    /**
</span>     * Creates new DOM element(s) and overwrites the contents of el with them.
     * @param {String/HTMLElement/Ext.Element} el The context element
     * @param {Object/String} o The DOM object spec (and children) or raw HTML blob
     * @param {Boolean} [returnElement] true to return an Ext.Element
     * @return {HTMLElement/Ext.Element} The new node
     */
    overwrite: function(el, html, returnElement) {
        var newNode;

        el = Ext.getDom(el);
        html = this.markup(html);

        // IE Inserting HTML into a table/tbody/tr requires extra processing: http://www.ericvasilik.com/2006/07/code-karma.html
        if (Ext.isIE &amp;&amp; this.tableRe.test(el.tagName)) {
            // Clearing table elements requires removal of all elements.
            while (el.firstChild) {
                el.removeChild(el.firstChild);
            }
            if (html) {
                newNode = this.insertHtml(&#39;afterbegin&#39;, el, html);
                return returnElement ? Ext.get(newNode) : newNode;
            }
            return null;
        }
        el.innerHTML = html;
        return returnElement ? Ext.get(el.firstChild) : el.firstChild;
    },

    insertHtml: function(where, el, html) {
        var hashVal,
            range,
            rangeEl,
            setStart,
            frag;

        where = where.toLowerCase();

        // Has fast HTML insertion into existing DOM: http://www.w3.org/TR/html5/apis-in-html-documents.html#insertadjacenthtml
        if (el.insertAdjacentHTML) {

            // IE&#39;s incomplete table implementation: http://www.ericvasilik.com/2006/07/code-karma.html
            if (Ext.isIE &amp;&amp; this.tableRe.test(el.tagName) &amp;&amp; (frag = this.insertIntoTable(el.tagName.toLowerCase(), where, el, html))) {
                return frag;
            }

            if ((hashVal = fullPositionHash[where])) {

                if (Ext.global.MSApp &amp;&amp; Ext.global.MSApp.execUnsafeLocalFunction) {
                    //ALLOW MS TO EXECUTE THIS CODE FOR NATIVE WINDOWS 8 DESKTOP APPS
                    MSApp.execUnsafeLocalFunction(function () {
                        el.insertAdjacentHTML(hashVal[0], html);
                    });
                } else {
                    el.insertAdjacentHTML(hashVal[0], html);
                }

                return el[hashVal[1]];
            }
            // if (not IE and context element is an HTMLElement) or TextNode
        } else {
            // we cannot insert anything inside a textnode so...
            if (el.nodeType === 3) {
                where = where === &#39;afterbegin&#39; ? &#39;beforebegin&#39; : where;
                where = where === &#39;beforeend&#39; ? &#39;afterend&#39; : where;
            }
            range = Ext.supports.CreateContextualFragment ? el.ownerDocument.createRange() : undefined;
            setStart = &#39;setStart&#39; + (this.endRe.test(where) ? &#39;After&#39; : &#39;Before&#39;);
            if (bb_ae_PositionHash[where]) {
                if (range) {
                    range[setStart](el);
                    frag = range.createContextualFragment(html);
                } else {
                    frag = this.createContextualFragment(html);
                }
                el.parentNode.insertBefore(frag, where == beforebegin ? el : el.nextSibling);
                return el[(where == beforebegin ? &#39;previous&#39; : &#39;next&#39;) + &#39;Sibling&#39;];
            } else {
                rangeEl = (where == afterbegin ? &#39;first&#39; : &#39;last&#39;) + &#39;Child&#39;;
                if (el.firstChild) {
                    if (range) {
                        range[setStart](el[rangeEl]);
                        frag = range.createContextualFragment(html);
                    } else {
                        frag = this.createContextualFragment(html);
                    }

                    if (where == afterbegin) {
                        el.insertBefore(frag, el.firstChild);
                    } else {
                        el.appendChild(frag);
                    }
                } else {
                    el.innerHTML = html;
                }
                return el[rangeEl];
            }
        }
        //&lt;debug&gt;
        Ext.Error.raise({
            sourceClass: &#39;Ext.DomHelper&#39;,
            sourceMethod: &#39;insertHtml&#39;,
            htmlToInsert: html,
            targetElement: el,
            msg: &#39;Illegal insertion point reached: &quot;&#39; + where + &#39;&quot;&#39;
        });
        //&lt;/debug&gt;
    },

<span id='Ext-dom-Helper-method-createTemplate'>    /**
</span>     * Creates a new Ext.Template from the DOM object spec.
     * @param {Object} o The DOM object spec (and children)
     * @return {Ext.Template} The new template
     */
    createTemplate: function(o) {
        var html = this.markup(o);
        return new Ext.Template(html);
    }

};
})(), function() {
    Ext.ns(&#39;Ext.core&#39;);
    Ext.DomHelper = Ext.core.DomHelper = new this;
});
</pre>
</body>
</html>
